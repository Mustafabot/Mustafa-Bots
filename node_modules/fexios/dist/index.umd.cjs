(function(c,d){typeof exports=="object"&&typeof module<"u"?d(exports):typeof define=="function"&&define.amd?define(["exports"],d):(c=typeof globalThis<"u"?globalThis:c||self,d(c.Fexios={}))})(this,function(c){"use strict";/**
 * Fexios
 * @desc Fetch based HTTP client with similar API to axios for browser and Node.js
 *
 * @license MIT
 * @author dragon-fish <dragon-fish@qq.com>
 */class d{constructor(o={}){this.baseConfigs=o,this.hooks=[],this.DEFAULT_CONFIGS={baseURL:"",timeout:60*1e3,credentials:"same-origin",headers:{},query:{},responseType:"json"},this.ALL_METHODS=["get","post","put","patch","delete","head","options","trace"],this.METHODS_WITHOUT_BODY=["get","head","options","trace"],this.interceptors={request:this.createInterceptor("beforeRequest"),response:this.createInterceptor("afterResponse")},this.create=d.create,this.ALL_METHODS.forEach(this.createMethodShortcut.bind(this))}async request(o,t){var T,_,p,g;let e=t=t||{};e.url=o.toString(),e=await this.emit("beforeInit",e);const s=t.baseURL||this.baseConfigs.baseURL||((T=globalThis.location)==null?void 0:T.href),h=s?new URL(s,(_=globalThis.location)==null?void 0:_.href):void 0,i=new URL(e.url.toString(),h);if(e.url=i.href,e.baseURL=h?h.href:i.origin,e.headers=this.mergeHeaders(this.baseConfigs.headers,t.headers),e.query=this.mergeQuery(this.baseConfigs.query,i.searchParams,t.query),i.search=new URLSearchParams(e.query).toString(),e.url=i.toString(),this.METHODS_WITHOUT_BODY.includes((p=e.method)==null?void 0:p.toLocaleLowerCase())&&e.body)throw new u("BODY_NOT_ALLOWED",`Request method "${e.method}" does not allow body`);e=await this.emit("beforeRequest",e);let r;typeof e.body<"u"&&e.body!==null&&(e.body instanceof Blob||e.body instanceof FormData||e.body instanceof URLSearchParams?r=e.body:typeof e.body=="object"?(r=JSON.stringify(e.body),e.headers["content-type"]="application/json; charset=UTF-8"):r=e.body),!((g=t.headers)!=null&&g["content-type"])&&r&&(r instanceof FormData||r instanceof URLSearchParams?typeof r=="string"&&typeof e.body=="object"?e.headers["content-type"]="application/json; charset=UTF-8":r instanceof Blob&&(e.headers["content-type"]=r.type):delete e.headers["content-type"]),e.body=r,e=await this.emit("afterBodyTransformed",e);const a=e.abortController||globalThis.AbortController?new AbortController:void 0,y=new Request(e.url,{method:e.method||"GET",credentials:e.credentials,headers:e.headers,body:e.body,signal:a==null?void 0:a.signal});e.rawRequest=y,e=await this.emit("beforeActualFetch",e);const f=e.timeout||this.baseConfigs.timeout||60*1e3,R=setTimeout(()=>{if(a==null||a.abort(),!a)throw new u("TIMEOUT",`Request timed out after ${f}ms`,e)},f),w=await fetch(e.rawRequest).catch(L=>{throw new u("NETWORK_ERROR",L.message,e)}).finally(()=>{clearTimeout(R)});return e.rawResponse=w,e.response=await m(w,e.responseType),e.data=e.response.data,e.headers=e.response.headers,this.emit("afterResponse",e)}mergeQuery(o,...t){const e=new URLSearchParams(o);for(const s of t)new URLSearchParams(s).forEach((i,r)=>{e.set(r,i)});return Object.fromEntries(e)}mergeHeaders(o,...t){const e={},s=new Headers(o);for(const h of t)new Headers(h).forEach((r,a)=>{s.set(a,r)});return s.forEach((h,i)=>{e[i]=h}),e}async emit(o,t){const e=this.hooks.filter(s=>s.event===o);try{let s=0;for(const h of e){const i=`${o}#${h.action.name||s}`,r=Symbol("FexiosHookContext");t.__hook_symbol__=r;const a=await h.action.bind(this)(t);if(t.__hook_symbol__!==r)throw new u("HOOK_CONTEXT_CHANGED",`Hook "${i}" should not override the original FexiosContext object.`);if(a===!1)throw new u("ABORTED_BY_HOOK",`Request aborted by hook "${i}"`,t);if(typeof a=="object"&&a.__hook_symbol__===r)t=a;else{const y=globalThis["".concat("console")];try{throw new u("UNEXPECTED_HOOK_RETURN",`Hook "${i}" should return the original FexiosContext or return false to abort the request, but got "${a}".`)}catch(f){y.warn(f.stack||f)}}delete t.__hook_symbol__,s++}}catch(s){return Promise.reject(s)}return t}on(o,t,e=!1){if(typeof t!="function")throw new u("INVALID_HOOK_CALLBACK",`Hook "${t}" should be a function, but got "${typeof t}"`);return this.hooks[e?"unshift":"push"]({event:o,action:t}),this}createInterceptor(o){return{handlers:()=>this.hooks.filter(t=>t.event===o).map(t=>t.action),use:(t,e=!1)=>this.on(o,t,e),clear:()=>{this.hooks=this.hooks.filter(t=>t.event!==o)}}}createMethodShortcut(o){return Object.defineProperty(this,o,{value:(t,e,s)=>(this.METHODS_WITHOUT_BODY.includes(o.toLocaleLowerCase())?s=e:(s=s||{},s.body=e),this.request(t,{...s,method:o}))}),this}extends(o){const t=new d({...this.baseConfigs,...o});return t.hooks=[...this.hooks],t}static create(o){return new d(o)}}class u extends Error{constructor(o,t,e){super(t),this.code=o,this.context=e,this.name="FexiosError"}}class l extends u{constructor(o,t){super(t.statusText,o),this.response=t,this.name="FexiosResponseError"}}const E=n=>!(n instanceof l)&&n instanceof u;async function m(n,o="json"){let t;o==="blob"&&(t=await n.clone().blob().catch(()=>{})),t||(t=await n.clone().json().catch(()=>n.clone().text()));const e={rawResponse:n,data:t,ok:n.ok,status:n.status,statusText:n.statusText,headers:n.headers};if(!n.ok)throw new l(`Request failed with status code ${n.status}`,e);return e}const O=b();function b(n){return d.create(n)}typeof window<"u"&&(window.fexios=b()),c.Fexios=d,c.FexiosError=u,c.FexiosResponseError=l,c.createFexios=b,c.createFexiosResponse=m,c.default=O,c.isFexiosError=E,Object.defineProperties(c,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
//# sourceMappingURL=index.umd.cjs.map

var Fexios=function(u){"use strict";/**
 * Fexios
 * @desc Fetch based HTTP client with similar API to axios for browser and Node.js
 *
 * @license MIT
 * @author dragon-fish <dragon-fish@qq.com>
 */class d{constructor(o={}){this.baseConfigs=o,this.hooks=[],this.DEFAULT_CONFIGS={baseURL:"",timeout:6e4,credentials:"same-origin",headers:{},query:{},responseType:"json"},this.ALL_METHODS=["get","post","put","patch","delete","head","options","trace"],this.METHODS_WITHOUT_BODY=["get","head","options","trace"],this.interceptors={request:this.createInterceptor("beforeRequest"),response:this.createInterceptor("afterResponse")},this.create=d.create,this.ALL_METHODS.forEach(this.createMethodShortcut.bind(this))}async request(o,t){var _,T,g,E;let e=t=t||{};e.url=o.toString(),e=await this.emit("beforeInit",e);const s=t.baseURL||this.baseConfigs.baseURL||((_=globalThis.location)==null?void 0:_.href),c=s?new URL(s,(T=globalThis.location)==null?void 0:T.href):void 0,i=new URL(e.url.toString(),c);if(e.url=i.href,e.baseURL=c?c.href:i.origin,e.headers=this.mergeHeaders(this.baseConfigs.headers,t.headers),e.query=this.mergeQuery(this.baseConfigs.query,i.searchParams,t.query),i.search=new URLSearchParams(e.query).toString(),e.url=i.toString(),this.METHODS_WITHOUT_BODY.includes((g=e.method)==null?void 0:g.toLocaleLowerCase())&&e.body)throw new h("BODY_NOT_ALLOWED",`Request method "${e.method}" does not allow body`);e=await this.emit("beforeRequest",e);let r;typeof e.body<"u"&&e.body!==null&&(e.body instanceof Blob||e.body instanceof FormData||e.body instanceof URLSearchParams?r=e.body:typeof e.body=="object"?(r=JSON.stringify(e.body),e.headers["content-type"]="application/json; charset=UTF-8"):r=e.body),!((E=t.headers)!=null&&E["content-type"])&&r&&(r instanceof FormData||r instanceof URLSearchParams?typeof r=="string"&&typeof e.body=="object"?e.headers["content-type"]="application/json; charset=UTF-8":r instanceof Blob&&(e.headers["content-type"]=r.type):delete e.headers["content-type"]),e.body=r,e=await this.emit("afterBodyTransformed",e);const n=e.abortController||globalThis.AbortController?new AbortController:void 0,y=new Request(e.url,{method:e.method||"GET",credentials:e.credentials,headers:e.headers,body:e.body,signal:n==null?void 0:n.signal});e.rawRequest=y,e=await this.emit("beforeActualFetch",e);const l=e.timeout||this.baseConfigs.timeout||60*1e3,p=setTimeout(()=>{if(n==null||n.abort(),!n)throw new h("TIMEOUT",`Request timed out after ${l}ms`,e)},l),w=await fetch(e.rawRequest).catch(L=>{throw new h("NETWORK_ERROR",L.message,e)}).finally(()=>{clearTimeout(p)});return e.rawResponse=w,e.response=await m(w,e.responseType),e.data=e.response.data,e.headers=e.response.headers,this.emit("afterResponse",e)}mergeQuery(o,...t){const e=new URLSearchParams(o);for(const s of t)new URLSearchParams(s).forEach((i,r)=>{e.set(r,i)});return Object.fromEntries(e)}mergeHeaders(o,...t){const e={},s=new Headers(o);for(const c of t)new Headers(c).forEach((r,n)=>{s.set(n,r)});return s.forEach((c,i)=>{e[i]=c}),e}async emit(o,t){const e=this.hooks.filter(s=>s.event===o);try{let s=0;for(const c of e){const i=`${o}#${c.action.name||s}`,r=Symbol("FexiosHookContext");t.__hook_symbol__=r;const n=await c.action.bind(this)(t);if(t.__hook_symbol__!==r)throw new h("HOOK_CONTEXT_CHANGED",`Hook "${i}" should not override the original FexiosContext object.`);if(n===!1)throw new h("ABORTED_BY_HOOK",`Request aborted by hook "${i}"`,t);if(typeof n=="object"&&n.__hook_symbol__===r)t=n;else{const y=globalThis["".concat("console")];try{throw new h("UNEXPECTED_HOOK_RETURN",`Hook "${i}" should return the original FexiosContext or return false to abort the request, but got "${n}".`)}catch(l){y.warn(l.stack||l)}}delete t.__hook_symbol__,s++}}catch(s){return Promise.reject(s)}return t}on(o,t,e=!1){if(typeof t!="function")throw new h("INVALID_HOOK_CALLBACK",`Hook "${t}" should be a function, but got "${typeof t}"`);return this.hooks[e?"unshift":"push"]({event:o,action:t}),this}createInterceptor(o){return{handlers:()=>this.hooks.filter(t=>t.event===o).map(t=>t.action),use:(t,e=!1)=>this.on(o,t,e),clear:()=>{this.hooks=this.hooks.filter(t=>t.event!==o)}}}createMethodShortcut(o){return Object.defineProperty(this,o,{value:(t,e,s)=>(this.METHODS_WITHOUT_BODY.includes(o.toLocaleLowerCase())?s=e:(s=s||{},s.body=e),this.request(t,{...s,method:o}))}),this}extends(o){const t=new d({...this.baseConfigs,...o});return t.hooks=[...this.hooks],t}static create(o){return new d(o)}}class h extends Error{constructor(o,t,e){super(t),this.code=o,this.context=e,this.name="FexiosError"}}class f extends h{constructor(o,t){super(t.statusText,o),this.response=t,this.name="FexiosResponseError"}}const O=a=>!(a instanceof f)&&a instanceof h;async function m(a,o="json"){let t;o==="blob"&&(t=await a.clone().blob().catch(()=>{})),t||(t=await a.clone().json().catch(()=>a.clone().text()));const e={rawResponse:a,data:t,ok:a.ok,status:a.status,statusText:a.statusText,headers:a.headers};if(!a.ok)throw new f(`Request failed with status code ${a.status}`,e);return e}const R=b();function b(a){return d.create(a)}return typeof window<"u"&&(window.fexios=b()),u.Fexios=d,u.FexiosError=h,u.FexiosResponseError=f,u.createFexios=b,u.createFexiosResponse=m,u.default=R,u.isFexiosError=O,Object.defineProperties(u,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}}),u}({});
//# sourceMappingURL=index.iife.js.map

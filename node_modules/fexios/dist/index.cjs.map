{"version":3,"file":"index.cjs","sources":["../src/index.ts"],"sourcesContent":["/**\r\n * Fexios\r\n * @desc Fetch based HTTP client with similar API to axios for browser and Node.js\r\n *\r\n * @license MIT\r\n * @author dragon-fish <dragon-fish@qq.com>\r\n */\r\n\r\nexport class Fexios {\r\n  protected hooks: FexiosHookStore[] = []\r\n  readonly DEFAULT_CONFIGS: FexiosConfigs = {\r\n    baseURL: '',\r\n    timeout: 60 * 1000,\r\n    credentials: 'same-origin',\r\n    headers: {},\r\n    query: {},\r\n    responseType: 'json',\r\n  }\r\n  private readonly ALL_METHODS: FexiosMethods[] = [\r\n    'get',\r\n    'post',\r\n    'put',\r\n    'patch',\r\n    'delete',\r\n    'head',\r\n    'options',\r\n    'trace',\r\n  ]\r\n  private readonly METHODS_WITHOUT_BODY: FexiosMethods[] = [\r\n    'get',\r\n    'head',\r\n    'options',\r\n    'trace',\r\n  ]\r\n\r\n  constructor(public baseConfigs: Partial<FexiosConfigs> = {}) {\r\n    this.ALL_METHODS.forEach(this.createMethodShortcut.bind(this))\r\n  }\r\n\r\n  async request<T = any>(\r\n    url: string | URL,\r\n    options?: Partial<FexiosRequestOptions>\r\n  ): Promise<FexiosFinalContext<T>> {\r\n    let ctx: FexiosContext = (options = options || {}) as any\r\n    ctx.url = url.toString()\r\n    ctx = await this.emit('beforeInit', ctx)\r\n\r\n    const baseUrlString =\r\n      options.baseURL || this.baseConfigs.baseURL || globalThis.location?.href\r\n    const baseURL = baseUrlString\r\n      ? new URL(baseUrlString, globalThis.location?.href)\r\n      : undefined\r\n    const reqURL = new URL(ctx.url.toString(), baseURL)\r\n    ctx.url = reqURL.href\r\n    ctx.baseURL = baseURL ? baseURL.href : reqURL.origin\r\n\r\n    ctx.headers = this.mergeHeaders(\r\n      this.baseConfigs.headers,\r\n      options.headers\r\n    ) as any\r\n    ctx.query = this.mergeQuery(\r\n      this.baseConfigs.query,\r\n      reqURL.searchParams,\r\n      options.query\r\n    )\r\n\r\n    reqURL.search = new URLSearchParams(ctx.query as any).toString()\r\n    ctx.url = reqURL.toString()\r\n\r\n    if (\r\n      this.METHODS_WITHOUT_BODY.includes(\r\n        ctx.method?.toLocaleLowerCase() as FexiosMethods\r\n      ) &&\r\n      ctx.body\r\n    ) {\r\n      throw new FexiosError(\r\n        'BODY_NOT_ALLOWED',\r\n        `Request method \"${ctx.method}\" does not allow body`\r\n      )\r\n    }\r\n\r\n    ctx = await this.emit('beforeRequest', ctx)\r\n\r\n    let body: string | FormData | URLSearchParams | Blob | undefined\r\n    if (typeof ctx.body !== 'undefined' && ctx.body !== null) {\r\n      // Automatically transform JSON object to JSON string\r\n      if (\r\n        ctx.body instanceof Blob ||\r\n        ctx.body instanceof FormData ||\r\n        ctx.body instanceof URLSearchParams\r\n      ) {\r\n        body = ctx.body\r\n      } else if (typeof ctx.body === 'object') {\r\n        body = JSON.stringify(ctx.body)\r\n        ;(ctx.headers as any)['content-type'] =\r\n          'application/json; charset=UTF-8'\r\n      } else {\r\n        body = ctx.body\r\n      }\r\n    }\r\n\r\n    // Adjust content-type header\r\n    if (!(options.headers as any)?.['content-type'] && body) {\r\n      // If body is FormData or URLSearchParams, simply delete content-type header to let Request constructor handle it\r\n      if (!(body instanceof FormData || body instanceof URLSearchParams)) {\r\n        delete (ctx.headers as any)['content-type']\r\n      }\r\n      // If body is a string and ctx.body is an object, it means ctx.body is a JSON string\r\n      else if (typeof body === 'string' && typeof ctx.body === 'object') {\r\n        ;(ctx.headers as any)['content-type'] =\r\n          'application/json; charset=UTF-8'\r\n      }\r\n      // If body is a Blob, set content-type header to the Blob's type\r\n      else if (body instanceof Blob) {\r\n        ;(ctx.headers as any)['content-type'] = body.type\r\n      }\r\n    }\r\n\r\n    ctx.body = body\r\n    ctx = await this.emit('afterBodyTransformed', ctx)\r\n\r\n    const abortController =\r\n      ctx.abortController || globalThis.AbortController\r\n        ? new AbortController()\r\n        : undefined\r\n    const rawRequest = new Request(ctx.url, {\r\n      method: ctx.method || 'GET',\r\n      credentials: ctx.credentials,\r\n      headers: ctx.headers,\r\n      body: ctx.body as any,\r\n      signal: abortController?.signal,\r\n    })\r\n    ctx.rawRequest = rawRequest\r\n\r\n    ctx = await this.emit('beforeActualFetch', ctx)\r\n\r\n    const timeout = ctx.timeout || this.baseConfigs.timeout || 60 * 1000\r\n    const timer = setTimeout(() => {\r\n      abortController?.abort()\r\n      if (!abortController) {\r\n        throw new FexiosError(\r\n          'TIMEOUT',\r\n          `Request timed out after ${timeout}ms`,\r\n          ctx\r\n        )\r\n      }\r\n    }, timeout)\r\n    const rawResponse = await fetch(ctx.rawRequest!)\r\n      .catch((err) => {\r\n        throw new FexiosError('NETWORK_ERROR', err.message, ctx)\r\n      })\r\n      .finally(() => {\r\n        clearTimeout(timer)\r\n      })\r\n\r\n    ctx.rawResponse = rawResponse\r\n    ctx.response = await createFexiosResponse(rawResponse, ctx.responseType)\r\n    ctx.data = ctx.response.data\r\n    ctx.headers = ctx.response.headers\r\n\r\n    return this.emit('afterResponse', ctx) as any\r\n  }\r\n\r\n  mergeQuery(\r\n    base: Record<string, any> | string | URLSearchParams | undefined,\r\n    ...income: (Record<string, any> | string | URLSearchParams | undefined)[]\r\n  ): Record<string, any> {\r\n    const baseQuery = new URLSearchParams(base)\r\n    for (const incomeQuery of income) {\r\n      const params = new URLSearchParams(incomeQuery)\r\n      params.forEach((value, key) => {\r\n        baseQuery.set(key, value)\r\n      })\r\n    }\r\n    return Object.fromEntries(baseQuery)\r\n  }\r\n  mergeHeaders(\r\n    base: Record<string, any> | Headers | undefined,\r\n    ...income: (Record<string, any> | Headers | undefined)[]\r\n  ): Record<string, any> {\r\n    const headersObject: any = {}\r\n    const baseHeaders = new Headers(base)\r\n    for (const incomeHeaders of income) {\r\n      const header = new Headers(incomeHeaders)\r\n      header.forEach((value, key) => {\r\n        baseHeaders.set(key, value)\r\n      })\r\n    }\r\n    baseHeaders.forEach((value, key) => {\r\n      headersObject[key] = value\r\n    })\r\n    return headersObject\r\n  }\r\n\r\n  async emit<C = FexiosContext>(event: FexiosLifecycleEvents, ctx: C) {\r\n    const hooks = this.hooks.filter((hook) => hook.event === event)\r\n    try {\r\n      let index = 0\r\n      for (const hook of hooks) {\r\n        const hookName = `${event}#${hook.action.name || index}`\r\n\r\n        // Set a symbol to check if the hook overrides the original context\r\n        const symbol = Symbol('FexiosHookContext')\r\n        ;(ctx as any).__hook_symbol__ = symbol\r\n\r\n        const newCtx = await (hook.action.bind(this) as FexiosHook<C>)(ctx)\r\n\r\n        // Check if the hook overrides the original context\r\n        if ((ctx as any).__hook_symbol__ !== symbol) {\r\n          throw new FexiosError(\r\n            'HOOK_CONTEXT_CHANGED',\r\n            `Hook \"${hookName}\" should not override the original FexiosContext object.`\r\n          )\r\n        }\r\n\r\n        // Excepted abort signal\r\n        if (newCtx === false) {\r\n          throw new FexiosError(\r\n            'ABORTED_BY_HOOK',\r\n            `Request aborted by hook \"${hookName}\"`,\r\n            ctx as FexiosContext\r\n          )\r\n        }\r\n        // Good\r\n        else if (\r\n          typeof newCtx === 'object' &&\r\n          (newCtx as any).__hook_symbol__ === symbol\r\n        ) {\r\n          ctx = newCtx as C\r\n        }\r\n        // Unexpected return value\r\n        else {\r\n          // @ts-ignore prevent esbuild optimize\r\n          const console = globalThis[''.concat('console')]\r\n          try {\r\n            throw new FexiosError(\r\n              'UNEXPECTED_HOOK_RETURN',\r\n              `Hook \"${hookName}\" should return the original FexiosContext or return false to abort the request, but got \"${newCtx}\".`\r\n            )\r\n          } catch (e: any) {\r\n            console.warn(e.stack || e)\r\n          }\r\n        }\r\n\r\n        // Clean up\r\n        delete (ctx as any).__hook_symbol__\r\n\r\n        index++\r\n      }\r\n    } catch (e) {\r\n      return Promise.reject(e)\r\n    }\r\n    return ctx\r\n  }\r\n  on<C = FexiosContext>(\r\n    event: FexiosLifecycleEvents,\r\n    action: FexiosHook<C>,\r\n    prepend = false\r\n  ) {\r\n    if (typeof action !== 'function') {\r\n      throw new FexiosError(\r\n        'INVALID_HOOK_CALLBACK',\r\n        `Hook \"${action}\" should be a function, but got \"${typeof action}\"`\r\n      )\r\n    }\r\n    this.hooks[prepend ? 'unshift' : 'push']({\r\n      event,\r\n      action: action as FexiosHook,\r\n    })\r\n    return this\r\n  }\r\n\r\n  private createInterceptor<T extends FexiosLifecycleEvents>(\r\n    event: T\r\n  ): FexiosInterceptor {\r\n    return {\r\n      handlers: () =>\r\n        this.hooks\r\n          .filter((hook) => hook.event === event)\r\n          .map((hook) => hook.action),\r\n      use: <C = FexiosContext>(hook: FexiosHook<C>, prepend = false) => {\r\n        return this.on(event, hook, prepend)\r\n      },\r\n      clear: () => {\r\n        this.hooks = this.hooks.filter((hook) => hook.event !== event)\r\n      },\r\n    }\r\n  }\r\n  readonly interceptors: FexiosInterceptors = {\r\n    request: this.createInterceptor('beforeRequest'),\r\n    response: this.createInterceptor('afterResponse'),\r\n  }\r\n\r\n  private createMethodShortcut(method: FexiosMethods) {\r\n    Object.defineProperty(this, method, {\r\n      value: (\r\n        url: string | URL,\r\n        bodyOrQuery?: Record<string, any> | string | URLSearchParams,\r\n        options?: Partial<FexiosRequestOptions>\r\n      ) => {\r\n        if (\r\n          this.METHODS_WITHOUT_BODY.includes(\r\n            method.toLocaleLowerCase() as FexiosMethods\r\n          )\r\n        ) {\r\n          options = bodyOrQuery as any\r\n        } else {\r\n          options = options || {}\r\n          options.body = bodyOrQuery\r\n        }\r\n        return this.request(url, {\r\n          ...options,\r\n          method: method as FexiosMethods,\r\n        })\r\n      },\r\n    })\r\n    return this\r\n  }\r\n\r\n  extends(configs: Partial<FexiosConfigs>) {\r\n    const fexios = new Fexios({ ...this.baseConfigs, ...configs })\r\n    fexios.hooks = [...this.hooks]\r\n    return fexios\r\n  }\r\n\r\n  create = Fexios.create\r\n  static create(configs?: Partial<FexiosConfigs>) {\r\n    return new Fexios(configs)\r\n  }\r\n}\r\n\r\n// declare method shortcuts\r\nexport interface Fexios {\r\n  get: FexiosRequestShortcut<'get'>\r\n  post: FexiosRequestShortcut<'post'>\r\n  put: FexiosRequestShortcut<'put'>\r\n  patch: FexiosRequestShortcut<'patch'>\r\n  delete: FexiosRequestShortcut<'delete'>\r\n  head: FexiosRequestShortcut<'head'>\r\n  options: FexiosRequestShortcut<'options'>\r\n  trace: FexiosRequestShortcut<'trace'>\r\n}\r\n\r\nexport class FexiosError extends Error {\r\n  name = 'FexiosError'\r\n  constructor(\r\n    public code: string,\r\n    message?: string,\r\n    public context?: FexiosContext\r\n  ) {\r\n    super(message)\r\n  }\r\n}\r\nexport class FexiosResponseError<T> extends FexiosError {\r\n  name = 'FexiosResponseError'\r\n  constructor(message: string, public response: FexiosResponse<T>) {\r\n    super(response.statusText, message)\r\n  }\r\n}\r\n/**\r\n * Check if the error is a FexiosError that not caused by Response error\r\n */\r\nexport const isFexiosError = (e: any): boolean => {\r\n  return !(e instanceof FexiosResponseError) && e instanceof FexiosError\r\n}\r\n\r\nexport async function createFexiosResponse<T = any>(\r\n  rawResponse: Response,\r\n  contentType = 'json'\r\n): Promise<FexiosResponse<T>> {\r\n  let data: T\r\n  if (contentType === 'blob') {\r\n    data = (await rawResponse\r\n      .clone()\r\n      .blob()\r\n      .catch(() => {\r\n        // do nothing\r\n      })) as T\r\n  }\r\n  // @ts-expect-error\r\n  if (!data) {\r\n    data = (await rawResponse\r\n      .clone()\r\n      .json()\r\n      .catch(() => {\r\n        return rawResponse.clone().text()\r\n      })) as T\r\n  }\r\n\r\n  const response: FexiosResponse<T> = {\r\n    rawResponse,\r\n    data,\r\n    ok: rawResponse.ok,\r\n    status: rawResponse.status,\r\n    statusText: rawResponse.statusText,\r\n    headers: rawResponse.headers,\r\n  }\r\n\r\n  if (!rawResponse.ok) {\r\n    throw new FexiosResponseError(\r\n      `Request failed with status code ${rawResponse.status}`,\r\n      response as any\r\n    )\r\n  }\r\n  return response\r\n}\r\n\r\n// Support for direct import\r\nexport default createFexios()\r\nexport function createFexios(configs?: Partial<FexiosConfigs>) {\r\n  return Fexios.create(configs)\r\n}\r\n// Set global fexios instance for browser\r\ndeclare global {\r\n  interface Window {\r\n    fexios: Fexios\r\n  }\r\n}\r\nif (typeof window !== 'undefined') {\r\n  window.fexios = createFexios()\r\n}\r\n\r\nexport type AwaitAble<T = unknown> = Promise<T> | T\r\nexport interface FexiosConfigs {\r\n  baseURL: string\r\n  timeout: number\r\n  query: Record<string, string | number | boolean> | URLSearchParams\r\n  headers: Record<string, string> | Headers\r\n  credentials: 'omit' | 'same-origin' | 'include'\r\n  responseType: 'json' | 'blob' | 'text'\r\n}\r\nexport interface FexiosRequestOptions extends FexiosConfigs {\r\n  method?: FexiosMethods\r\n  body?: Record<string, any> | string | FormData | URLSearchParams\r\n  abortController?: AbortController\r\n}\r\nexport interface FexiosContext<T = any> extends FexiosRequestOptions {\r\n  url: string\r\n  rawRequest?: Request\r\n  rawResponse?: Response\r\n  response?: FexiosResponse\r\n  data?: T\r\n}\r\nexport type FexiosFinalContext<T = any> = Omit<\r\n  FexiosContext<T>,\r\n  'rawResponse' | 'response' | 'data' | 'headers'\r\n> & {\r\n  rawResponse: Response\r\n  response: FexiosResponse<T>\r\n  headers: Headers\r\n  data: T\r\n}\r\nexport interface FexiosResponse<T = any> {\r\n  rawResponse: Response\r\n  ok: boolean\r\n  status: number\r\n  statusText: string\r\n  headers: Headers\r\n  data: T\r\n}\r\nexport type FexiosHook<C = unknown> = (context: C) => AwaitAble<C | false>\r\nexport interface FexiosHookStore {\r\n  event: FexiosLifecycleEvents\r\n  action: FexiosHook\r\n}\r\nexport type FexiosLifecycleEvents =\r\n  | 'beforeInit'\r\n  | 'beforeRequest'\r\n  | 'afterBodyTransformed'\r\n  | 'beforeActualFetch'\r\n  | 'afterResponse'\r\nexport interface FexiosHooksNameMap {\r\n  beforeInit: FexiosContext\r\n  beforeRequest: FexiosContext\r\n  afterBodyTransformed: FexiosContext\r\n  beforeActualFetch: FexiosContext\r\n  afterResponse: FexiosFinalContext\r\n}\r\nexport interface FexiosInterceptor {\r\n  handlers: () => FexiosHook[]\r\n  use: <C = FexiosContext>(hook: FexiosHook<C>, prepend?: boolean) => Fexios\r\n  clear: () => void\r\n}\r\nexport interface FexiosInterceptors {\r\n  request: FexiosInterceptor\r\n  response: FexiosInterceptor\r\n}\r\n\r\ntype LowerAndUppercase<T extends string> = Lowercase<T> | Uppercase<T>\r\nexport type FexiosMethods = LowerAndUppercase<\r\n  'get' | 'post' | 'put' | 'patch' | 'delete' | 'head' | 'options' | 'trace'\r\n>\r\n\r\ntype MethodsWithoutBody = LowerAndUppercase<\r\n  'get' | 'head' | 'options' | 'trace'\r\n>\r\nexport type FexiosRequestShortcut<M extends FexiosMethods> =\r\n  M extends MethodsWithoutBody ? ShortcutWithoutBody : ShortcutWithBody\r\ntype ShortcutWithoutBody = <T = any>(\r\n  url: string | URL,\r\n  options?: Partial<FexiosRequestOptions>\r\n) => Promise<FexiosFinalContext<T>>\r\ntype ShortcutWithBody = <T = any>(\r\n  url: string | URL,\r\n  body?: Record<string, any> | string | URLSearchParams | FormData | null,\r\n  options?: Partial<FexiosRequestOptions>\r\n) => Promise<FexiosFinalContext<T>>\r\n"],"names":["Fexios","baseConfigs","url","options","ctx","baseUrlString","_a","baseURL","_b","reqURL","_c","FexiosError","body","_d","abortController","rawRequest","timeout","timer","rawResponse","err","createFexiosResponse","base","income","baseQuery","incomeQuery","value","key","headersObject","baseHeaders","incomeHeaders","event","hooks","hook","index","hookName","symbol","newCtx","console","e","action","prepend","method","bodyOrQuery","configs","fexios","code","message","context","FexiosResponseError","response","isFexiosError","contentType","data","createFexios"],"mappings":"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"}
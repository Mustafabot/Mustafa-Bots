/**
 * Fexios
 * @desc Fetch based HTTP client with similar API to axios for browser and Node.js
 *
 * @license MIT
 * @author dragon-fish <dragon-fish@qq.com>
 */
class u {
  constructor(s = {}) {
    this.baseConfigs = s, this.hooks = [], this.DEFAULT_CONFIGS = {
      baseURL: "",
      timeout: 60 * 1e3,
      credentials: "same-origin",
      headers: {},
      query: {},
      responseType: "json"
    }, this.ALL_METHODS = [
      "get",
      "post",
      "put",
      "patch",
      "delete",
      "head",
      "options",
      "trace"
    ], this.METHODS_WITHOUT_BODY = [
      "get",
      "head",
      "options",
      "trace"
    ], this.interceptors = {
      request: this.createInterceptor("beforeRequest"),
      response: this.createInterceptor("afterResponse")
    }, this.create = u.create, this.ALL_METHODS.forEach(this.createMethodShortcut.bind(this));
  }
  async request(s, t) {
    var b, y, m, w;
    let e = t = t || {};
    e.url = s.toString(), e = await this.emit("beforeInit", e);
    const o = t.baseURL || this.baseConfigs.baseURL || ((b = globalThis.location) == null ? void 0 : b.href), h = o ? new URL(o, (y = globalThis.location) == null ? void 0 : y.href) : void 0, i = new URL(e.url.toString(), h);
    if (e.url = i.href, e.baseURL = h ? h.href : i.origin, e.headers = this.mergeHeaders(
      this.baseConfigs.headers,
      t.headers
    ), e.query = this.mergeQuery(
      this.baseConfigs.query,
      i.searchParams,
      t.query
    ), i.search = new URLSearchParams(e.query).toString(), e.url = i.toString(), this.METHODS_WITHOUT_BODY.includes(
      (m = e.method) == null ? void 0 : m.toLocaleLowerCase()
    ) && e.body)
      throw new c(
        "BODY_NOT_ALLOWED",
        `Request method "${e.method}" does not allow body`
      );
    e = await this.emit("beforeRequest", e);
    let r;
    typeof e.body < "u" && e.body !== null && (e.body instanceof Blob || e.body instanceof FormData || e.body instanceof URLSearchParams ? r = e.body : typeof e.body == "object" ? (r = JSON.stringify(e.body), e.headers["content-type"] = "application/json; charset=UTF-8") : r = e.body), !((w = t.headers) != null && w["content-type"]) && r && (r instanceof FormData || r instanceof URLSearchParams ? typeof r == "string" && typeof e.body == "object" ? e.headers["content-type"] = "application/json; charset=UTF-8" : r instanceof Blob && (e.headers["content-type"] = r.type) : delete e.headers["content-type"]), e.body = r, e = await this.emit("afterBodyTransformed", e);
    const n = e.abortController || globalThis.AbortController ? new AbortController() : void 0, f = new Request(e.url, {
      method: e.method || "GET",
      credentials: e.credentials,
      headers: e.headers,
      body: e.body,
      signal: n == null ? void 0 : n.signal
    });
    e.rawRequest = f, e = await this.emit("beforeActualFetch", e);
    const d = e.timeout || this.baseConfigs.timeout || 60 * 1e3, p = setTimeout(() => {
      if (n == null || n.abort(), !n)
        throw new c(
          "TIMEOUT",
          `Request timed out after ${d}ms`,
          e
        );
    }, d), l = await fetch(e.rawRequest).catch((g) => {
      throw new c("NETWORK_ERROR", g.message, e);
    }).finally(() => {
      clearTimeout(p);
    });
    return e.rawResponse = l, e.response = await O(l, e.responseType), e.data = e.response.data, e.headers = e.response.headers, this.emit("afterResponse", e);
  }
  mergeQuery(s, ...t) {
    const e = new URLSearchParams(s);
    for (const o of t)
      new URLSearchParams(o).forEach((i, r) => {
        e.set(r, i);
      });
    return Object.fromEntries(e);
  }
  mergeHeaders(s, ...t) {
    const e = {}, o = new Headers(s);
    for (const h of t)
      new Headers(h).forEach((r, n) => {
        o.set(n, r);
      });
    return o.forEach((h, i) => {
      e[i] = h;
    }), e;
  }
  async emit(s, t) {
    const e = this.hooks.filter((o) => o.event === s);
    try {
      let o = 0;
      for (const h of e) {
        const i = `${s}#${h.action.name || o}`, r = Symbol("FexiosHookContext");
        t.__hook_symbol__ = r;
        const n = await h.action.bind(this)(t);
        if (t.__hook_symbol__ !== r)
          throw new c(
            "HOOK_CONTEXT_CHANGED",
            `Hook "${i}" should not override the original FexiosContext object.`
          );
        if (n === !1)
          throw new c(
            "ABORTED_BY_HOOK",
            `Request aborted by hook "${i}"`,
            t
          );
        if (typeof n == "object" && n.__hook_symbol__ === r)
          t = n;
        else {
          const f = globalThis["".concat("console")];
          try {
            throw new c(
              "UNEXPECTED_HOOK_RETURN",
              `Hook "${i}" should return the original FexiosContext or return false to abort the request, but got "${n}".`
            );
          } catch (d) {
            f.warn(d.stack || d);
          }
        }
        delete t.__hook_symbol__, o++;
      }
    } catch (o) {
      return Promise.reject(o);
    }
    return t;
  }
  on(s, t, e = !1) {
    if (typeof t != "function")
      throw new c(
        "INVALID_HOOK_CALLBACK",
        `Hook "${t}" should be a function, but got "${typeof t}"`
      );
    return this.hooks[e ? "unshift" : "push"]({
      event: s,
      action: t
    }), this;
  }
  createInterceptor(s) {
    return {
      handlers: () => this.hooks.filter((t) => t.event === s).map((t) => t.action),
      use: (t, e = !1) => this.on(s, t, e),
      clear: () => {
        this.hooks = this.hooks.filter((t) => t.event !== s);
      }
    };
  }
  createMethodShortcut(s) {
    return Object.defineProperty(this, s, {
      value: (t, e, o) => (this.METHODS_WITHOUT_BODY.includes(
        s.toLocaleLowerCase()
      ) ? o = e : (o = o || {}, o.body = e), this.request(t, {
        ...o,
        method: s
      }))
    }), this;
  }
  extends(s) {
    const t = new u({ ...this.baseConfigs, ...s });
    return t.hooks = [...this.hooks], t;
  }
  static create(s) {
    return new u(s);
  }
}
class c extends Error {
  constructor(s, t, e) {
    super(t), this.code = s, this.context = e, this.name = "FexiosError";
  }
}
class _ extends c {
  constructor(s, t) {
    super(t.statusText, s), this.response = t, this.name = "FexiosResponseError";
  }
}
const E = (a) => !(a instanceof _) && a instanceof c;
async function O(a, s = "json") {
  let t;
  s === "blob" && (t = await a.clone().blob().catch(() => {
  })), t || (t = await a.clone().json().catch(() => a.clone().text()));
  const e = {
    rawResponse: a,
    data: t,
    ok: a.ok,
    status: a.status,
    statusText: a.statusText,
    headers: a.headers
  };
  if (!a.ok)
    throw new _(
      `Request failed with status code ${a.status}`,
      e
    );
  return e;
}
const R = T();
function T(a) {
  return u.create(a);
}
typeof window < "u" && (window.fexios = T());
export {
  u as Fexios,
  c as FexiosError,
  _ as FexiosResponseError,
  T as createFexios,
  O as createFexiosResponse,
  R as default,
  E as isFexiosError
};
//# sourceMappingURL=index.js.map

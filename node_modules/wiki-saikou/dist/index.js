/**
* @vue/shared v3.5.8
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function Le(e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const s of e.split(",")) t[s] = 1;
  return (s) => s in t;
}
const Pe = Object.prototype.hasOwnProperty, V = (e, t) => Pe.call(e, t), O = Array.isArray, F = (e) => fe(e) === "[object Map]", qe = (e) => typeof e == "function", xe = (e) => typeof e == "string", H = (e) => typeof e == "symbol", W = (e) => e !== null && typeof e == "object", je = Object.prototype.toString, fe = (e) => je.call(e), Me = (e) => fe(e).slice(8, -1), Q = (e) => xe(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, q = (e, t) => !Object.is(e, t);
/**
* @vue/reactivity v3.5.8
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let d, he = 0, j;
function Ae(e) {
  e.flags |= 8, e.next = j, j = e;
}
function J() {
  he++;
}
function Z() {
  if (--he > 0)
    return;
  let e;
  for (; j; ) {
    let t = j;
    for (j = void 0; t; ) {
      const s = t.next;
      if (t.next = void 0, t.flags &= -9, t.flags & 1)
        try {
          t.trigger();
        } catch (n) {
          e || (e = n);
        }
      t = s;
    }
  }
  if (e) throw e;
}
function He(e) {
  for (let t = e.deps; t; t = t.nextDep)
    t.version = -1, t.prevActiveLink = t.dep.activeLink, t.dep.activeLink = t;
}
function Ce(e, t = !1) {
  let s, n = e.depsTail, r = n;
  for (; r; ) {
    const o = r.prevDep;
    r.version === -1 ? (r === n && (n = o), pe(r, t), Ue(r)) : s = r, r.dep.activeLink = r.prevActiveLink, r.prevActiveLink = void 0, r = o;
  }
  e.deps = s, e.depsTail = n;
}
function ke(e) {
  for (let t = e.deps; t; t = t.nextDep)
    if (t.dep.version !== t.version || t.dep.computed && (de(t.dep.computed) || t.dep.version !== t.version))
      return !0;
  return !!e._dirty;
}
function de(e) {
  if (e.flags & 4 && !(e.flags & 16) || (e.flags &= -17, e.globalVersion === M))
    return;
  e.globalVersion = M;
  const t = e.dep;
  if (e.flags |= 2, t.version > 0 && !e.isSSR && e.deps && !ke(e)) {
    e.flags &= -3;
    return;
  }
  const s = d, n = v;
  d = e, v = !0;
  try {
    He(e);
    const r = e.fn(e._value);
    (t.version === 0 || q(r, e._value)) && (e._value = r, t.version++);
  } catch (r) {
    throw t.version++, r;
  } finally {
    d = s, v = n, Ce(e, !0), e.flags &= -3;
  }
}
function pe(e, t = !1) {
  const { dep: s, prevSub: n, nextSub: r } = e;
  if (n && (n.nextSub = r, e.prevSub = void 0), r && (r.prevSub = n, e.nextSub = void 0), s.subs === e && (s.subs = n), !s.subs)
    if (s.computed) {
      s.computed.flags &= -5;
      for (let o = s.computed.deps; o; o = o.nextDep)
        pe(o, !0);
    } else s.map && !t && (s.map.delete(s.key), s.map.size || $.delete(s.target));
}
function Ue(e) {
  const { prevDep: t, nextDep: s } = e;
  t && (t.nextDep = s, e.prevDep = void 0), s && (s.prevDep = t, e.nextDep = void 0);
}
let v = !0;
const be = [];
function Ne() {
  be.push(v), v = !1;
}
function Ke() {
  const e = be.pop();
  v = e === void 0 ? !0 : e;
}
let M = 0;
class Fe {
  constructor(t, s) {
    this.sub = t, this.dep = s, this.version = s.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class ee {
  constructor(t) {
    this.computed = t, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.target = void 0, this.map = void 0, this.key = void 0;
  }
  track(t) {
    if (!d || !v || d === this.computed)
      return;
    let s = this.activeLink;
    if (s === void 0 || s.sub !== d)
      s = this.activeLink = new Fe(d, this), d.deps ? (s.prevDep = d.depsTail, d.depsTail.nextDep = s, d.depsTail = s) : d.deps = d.depsTail = s, d.flags & 4 && _e(s);
    else if (s.version === -1 && (s.version = this.version, s.nextDep)) {
      const n = s.nextDep;
      n.prevDep = s.prevDep, s.prevDep && (s.prevDep.nextDep = n), s.prevDep = d.depsTail, s.nextDep = void 0, d.depsTail.nextDep = s, d.depsTail = s, d.deps === s && (d.deps = n);
    }
    return s;
  }
  trigger(t) {
    this.version++, M++, this.notify(t);
  }
  notify(t) {
    J();
    try {
      for (let s = this.subs; s; s = s.prevSub)
        s.sub.notify() && s.sub.dep.notify();
    } finally {
      Z();
    }
  }
}
function _e(e) {
  const t = e.dep.computed;
  if (t && !e.dep.subs) {
    t.flags |= 20;
    for (let n = t.deps; n; n = n.nextDep)
      _e(n);
  }
  const s = e.dep.subs;
  s !== e && (e.prevSub = s, s && (s.nextSub = e)), e.dep.subs = e;
}
const $ = /* @__PURE__ */ new WeakMap(), E = Symbol(
  ""
), X = Symbol(
  ""
), A = Symbol(
  ""
);
function _(e, t, s) {
  if (v && d) {
    let n = $.get(e);
    n || $.set(e, n = /* @__PURE__ */ new Map());
    let r = n.get(s);
    r || (n.set(s, r = new ee()), r.target = e, r.map = n, r.key = s), r.track();
  }
}
function R(e, t, s, n, r, o) {
  const a = $.get(e);
  if (!a) {
    M++;
    return;
  }
  const i = (c) => {
    c && c.trigger();
  };
  if (J(), t === "clear")
    a.forEach(i);
  else {
    const c = O(e), f = c && Q(s);
    if (c && s === "length") {
      const l = Number(n);
      a.forEach((u, p) => {
        (p === "length" || p === A || !H(p) && p >= l) && i(u);
      });
    } else
      switch (s !== void 0 && i(a.get(s)), f && i(a.get(A)), t) {
        case "add":
          c ? f && i(a.get("length")) : (i(a.get(E)), F(e) && i(a.get(X)));
          break;
        case "delete":
          c || (i(a.get(E)), F(e) && i(a.get(X)));
          break;
        case "set":
          F(e) && i(a.get(E));
          break;
      }
  }
  Z();
}
function S(e) {
  const t = h(e);
  return t === e ? t : (_(t, "iterate", A), T(e) ? t : t.map(b));
}
function te(e) {
  return _(e = h(e), "iterate", A), e;
}
const $e = {
  __proto__: null,
  [Symbol.iterator]() {
    return Y(this, Symbol.iterator, b);
  },
  concat(...e) {
    return S(this).concat(
      ...e.map((t) => O(t) ? S(t) : t)
    );
  },
  entries() {
    return Y(this, "entries", (e) => (e[1] = b(e[1]), e));
  },
  every(e, t) {
    return g(this, "every", e, t, void 0, arguments);
  },
  filter(e, t) {
    return g(this, "filter", e, t, (s) => s.map(b), arguments);
  },
  find(e, t) {
    return g(this, "find", e, t, b, arguments);
  },
  findIndex(e, t) {
    return g(this, "findIndex", e, t, void 0, arguments);
  },
  findLast(e, t) {
    return g(this, "findLast", e, t, b, arguments);
  },
  findLastIndex(e, t) {
    return g(this, "findLastIndex", e, t, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(e, t) {
    return g(this, "forEach", e, t, void 0, arguments);
  },
  includes(...e) {
    return z(this, "includes", e);
  },
  indexOf(...e) {
    return z(this, "indexOf", e);
  },
  join(e) {
    return S(this).join(e);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...e) {
    return z(this, "lastIndexOf", e);
  },
  map(e, t) {
    return g(this, "map", e, t, void 0, arguments);
  },
  pop() {
    return x(this, "pop");
  },
  push(...e) {
    return x(this, "push", e);
  },
  reduce(e, ...t) {
    return ie(this, "reduce", e, t);
  },
  reduceRight(e, ...t) {
    return ie(this, "reduceRight", e, t);
  },
  shift() {
    return x(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(e, t) {
    return g(this, "some", e, t, void 0, arguments);
  },
  splice(...e) {
    return x(this, "splice", e);
  },
  toReversed() {
    return S(this).toReversed();
  },
  toSorted(e) {
    return S(this).toSorted(e);
  },
  toSpliced(...e) {
    return S(this).toSpliced(...e);
  },
  unshift(...e) {
    return x(this, "unshift", e);
  },
  values() {
    return Y(this, "values", b);
  }
};
function Y(e, t, s) {
  const n = te(e), r = n[t]();
  return n !== e && !T(e) && (r._next = r.next, r.next = () => {
    const o = r._next();
    return o.value && (o.value = s(o.value)), o;
  }), r;
}
const We = Array.prototype;
function g(e, t, s, n, r, o) {
  const a = te(e), i = a !== e && !T(e), c = a[t];
  if (c !== We[t]) {
    const u = c.apply(e, o);
    return i ? b(u) : u;
  }
  let f = s;
  a !== e && (i ? f = function(u, p) {
    return s.call(this, b(u), p, e);
  } : s.length > 2 && (f = function(u, p) {
    return s.call(this, u, p, e);
  }));
  const l = c.call(a, f, n);
  return i && r ? r(l) : l;
}
function ie(e, t, s, n) {
  const r = te(e);
  let o = s;
  return r !== e && (T(e) ? s.length > 3 && (o = function(a, i, c) {
    return s.call(this, a, i, c, e);
  }) : o = function(a, i, c) {
    return s.call(this, a, b(i), c, e);
  }), r[t](o, ...n);
}
function z(e, t, s) {
  const n = h(e);
  _(n, "iterate", A);
  const r = n[t](...s);
  return (r === -1 || r === !1) && ct(s[0]) ? (s[0] = h(s[0]), n[t](...s)) : r;
}
function x(e, t, s = []) {
  Ne(), J();
  const n = h(e)[t].apply(e, s);
  return Z(), Ke(), n;
}
const Be = /* @__PURE__ */ Le("__proto__,__v_isRef,__isVue"), ge = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((e) => e !== "arguments" && e !== "caller").map((e) => Symbol[e]).filter(H)
);
function Ye(e) {
  H(e) || (e = String(e));
  const t = h(this);
  return _(t, "has", e), t.hasOwnProperty(e);
}
class we {
  constructor(t = !1, s = !1) {
    this._isReadonly = t, this._isShallow = s;
  }
  get(t, s, n) {
    const r = this._isReadonly, o = this._isShallow;
    if (s === "__v_isReactive")
      return !r;
    if (s === "__v_isReadonly")
      return r;
    if (s === "__v_isShallow")
      return o;
    if (s === "__v_raw")
      return n === (r ? o ? ot : ve : o ? nt : ye).get(t) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(t) === Object.getPrototypeOf(n) ? t : void 0;
    const a = O(t);
    if (!r) {
      let c;
      if (a && (c = $e[s]))
        return c;
      if (s === "hasOwnProperty")
        return Ye;
    }
    const i = Reflect.get(
      t,
      s,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      D(t) ? t : n
    );
    return (H(s) ? ge.has(s) : Be(s)) || (r || _(t, "get", s), o) ? i : D(i) ? a && Q(s) ? i : i.value : W(i) ? r ? Te(i) : Re(i) : i;
  }
}
class ze extends we {
  constructor(t = !1) {
    super(!1, t);
  }
  set(t, s, n, r) {
    let o = t[s];
    if (!this._isShallow) {
      const c = P(o);
      if (!T(n) && !P(n) && (o = h(o), n = h(n)), !O(t) && D(o) && !D(n))
        return c ? !1 : (o.value = n, !0);
    }
    const a = O(t) && Q(s) ? Number(s) < t.length : V(t, s), i = Reflect.set(
      t,
      s,
      n,
      D(t) ? t : r
    );
    return t === h(r) && (a ? q(n, o) && R(t, "set", s, n) : R(t, "add", s, n)), i;
  }
  deleteProperty(t, s) {
    const n = V(t, s);
    t[s];
    const r = Reflect.deleteProperty(t, s);
    return r && n && R(t, "delete", s, void 0), r;
  }
  has(t, s) {
    const n = Reflect.has(t, s);
    return (!H(s) || !ge.has(s)) && _(t, "has", s), n;
  }
  ownKeys(t) {
    return _(
      t,
      "iterate",
      O(t) ? "length" : E
    ), Reflect.ownKeys(t);
  }
}
class Ge extends we {
  constructor(t = !1) {
    super(!0, t);
  }
  set(t, s) {
    return !0;
  }
  deleteProperty(t, s) {
    return !0;
  }
}
const Ve = /* @__PURE__ */ new ze(), Xe = /* @__PURE__ */ new Ge(), se = (e) => e, B = (e) => Reflect.getPrototypeOf(e);
function C(e, t, s = !1, n = !1) {
  e = e.__v_raw;
  const r = h(e), o = h(t);
  s || (q(t, o) && _(r, "get", t), _(r, "get", o));
  const { has: a } = B(r), i = n ? se : s ? re : b;
  if (a.call(r, t))
    return i(e.get(t));
  if (a.call(r, o))
    return i(e.get(o));
  e !== r && e.get(t);
}
function k(e, t = !1) {
  const s = this.__v_raw, n = h(s), r = h(e);
  return t || (q(e, r) && _(n, "has", e), _(n, "has", r)), e === r ? s.has(e) : s.has(e) || s.has(r);
}
function U(e, t = !1) {
  return e = e.__v_raw, !t && _(h(e), "iterate", E), Reflect.get(e, "size", e);
}
function ae(e, t = !1) {
  !t && !T(e) && !P(e) && (e = h(e));
  const s = h(this);
  return B(s).has.call(s, e) || (s.add(e), R(s, "add", e, e)), this;
}
function ce(e, t, s = !1) {
  !s && !T(t) && !P(t) && (t = h(t));
  const n = h(this), { has: r, get: o } = B(n);
  let a = r.call(n, e);
  a || (e = h(e), a = r.call(n, e));
  const i = o.call(n, e);
  return n.set(e, t), a ? q(t, i) && R(n, "set", e, t) : R(n, "add", e, t), this;
}
function ue(e) {
  const t = h(this), { has: s, get: n } = B(t);
  let r = s.call(t, e);
  r || (e = h(e), r = s.call(t, e)), n && n.call(t, e);
  const o = t.delete(e);
  return r && R(t, "delete", e, void 0), o;
}
function le() {
  const e = h(this), t = e.size !== 0, s = e.clear();
  return t && R(e, "clear", void 0, void 0), s;
}
function N(e, t) {
  return function(n, r) {
    const o = this, a = o.__v_raw, i = h(a), c = t ? se : e ? re : b;
    return !e && _(i, "iterate", E), a.forEach((f, l) => n.call(r, c(f), c(l), o));
  };
}
function K(e, t, s) {
  return function(...n) {
    const r = this.__v_raw, o = h(r), a = F(o), i = e === "entries" || e === Symbol.iterator && a, c = e === "keys" && a, f = r[e](...n), l = s ? se : t ? re : b;
    return !t && _(
      o,
      "iterate",
      c ? X : E
    ), {
      // iterator protocol
      next() {
        const { value: u, done: p } = f.next();
        return p ? { value: u, done: p } : {
          value: i ? [l(u[0]), l(u[1])] : l(u),
          done: p
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function w(e) {
  return function(...t) {
    return e === "delete" ? !1 : e === "clear" ? void 0 : this;
  };
}
function Qe() {
  const e = {
    get(o) {
      return C(this, o);
    },
    get size() {
      return U(this);
    },
    has: k,
    add: ae,
    set: ce,
    delete: ue,
    clear: le,
    forEach: N(!1, !1)
  }, t = {
    get(o) {
      return C(this, o, !1, !0);
    },
    get size() {
      return U(this);
    },
    has: k,
    add(o) {
      return ae.call(this, o, !0);
    },
    set(o, a) {
      return ce.call(this, o, a, !0);
    },
    delete: ue,
    clear: le,
    forEach: N(!1, !0)
  }, s = {
    get(o) {
      return C(this, o, !0);
    },
    get size() {
      return U(this, !0);
    },
    has(o) {
      return k.call(this, o, !0);
    },
    add: w("add"),
    set: w("set"),
    delete: w("delete"),
    clear: w("clear"),
    forEach: N(!0, !1)
  }, n = {
    get(o) {
      return C(this, o, !0, !0);
    },
    get size() {
      return U(this, !0);
    },
    has(o) {
      return k.call(this, o, !0);
    },
    add: w("add"),
    set: w("set"),
    delete: w("delete"),
    clear: w("clear"),
    forEach: N(!0, !0)
  };
  return [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((o) => {
    e[o] = K(o, !1, !1), s[o] = K(o, !0, !1), t[o] = K(o, !1, !0), n[o] = K(
      o,
      !0,
      !0
    );
  }), [
    e,
    s,
    t,
    n
  ];
}
const [
  Je,
  Ze,
  et,
  tt
] = /* @__PURE__ */ Qe();
function me(e, t) {
  const s = t ? e ? tt : et : e ? Ze : Je;
  return (n, r, o) => r === "__v_isReactive" ? !e : r === "__v_isReadonly" ? e : r === "__v_raw" ? n : Reflect.get(
    V(s, r) && r in n ? s : n,
    r,
    o
  );
}
const st = {
  get: /* @__PURE__ */ me(!1, !1)
}, rt = {
  get: /* @__PURE__ */ me(!0, !1)
}, ye = /* @__PURE__ */ new WeakMap(), nt = /* @__PURE__ */ new WeakMap(), ve = /* @__PURE__ */ new WeakMap(), ot = /* @__PURE__ */ new WeakMap();
function it(e) {
  switch (e) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function at(e) {
  return e.__v_skip || !Object.isExtensible(e) ? 0 : it(Me(e));
}
function Re(e) {
  return P(e) ? e : Ee(
    e,
    !1,
    Ve,
    st,
    ye
  );
}
function Te(e) {
  return Ee(
    e,
    !0,
    Xe,
    rt,
    ve
  );
}
function Ee(e, t, s, n, r) {
  if (!W(e) || e.__v_raw && !(t && e.__v_isReactive))
    return e;
  const o = r.get(e);
  if (o)
    return o;
  const a = at(e);
  if (a === 0)
    return e;
  const i = new Proxy(
    e,
    a === 2 ? n : s
  );
  return r.set(e, i), i;
}
function P(e) {
  return !!(e && e.__v_isReadonly);
}
function T(e) {
  return !!(e && e.__v_isShallow);
}
function ct(e) {
  return e ? !!e.__v_raw : !1;
}
function h(e) {
  const t = e && e.__v_raw;
  return t ? h(t) : e;
}
const b = (e) => W(e) ? Re(e) : e, re = (e) => W(e) ? Te(e) : e;
function D(e) {
  return e ? e.__v_isRef === !0 : !1;
}
function G(e) {
  return ut(e, !1);
}
function ut(e, t) {
  return D(e) ? e : new lt(e, t);
}
class lt {
  constructor(t, s) {
    this.dep = new ee(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = s ? t : h(t), this._value = s ? t : b(t), this.__v_isShallow = s;
  }
  get value() {
    return this.dep.track(), this._value;
  }
  set value(t) {
    const s = this._rawValue, n = this.__v_isShallow || T(t) || P(t);
    t = n ? t : h(t), q(t, s) && (this._rawValue = t, this._value = n ? t : b(t), this.dep.trigger());
  }
}
class ft {
  constructor(t, s, n) {
    this.fn = t, this.setter = s, this._value = void 0, this.dep = new ee(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = M - 1, this.effect = this, this.__v_isReadonly = !s, this.isSSR = n;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    d !== this)
      return Ae(this), !0;
  }
  get value() {
    const t = this.dep.track();
    return de(this), t && (t.version = this.dep.version), this._value;
  }
  set value(t) {
    this.setter && this.setter(t);
  }
}
function ht(e, t, s = !1) {
  let n, r;
  return qe(e) ? n = e : (n = e.get, r = e.set), new ft(n, r, s);
}
/**
 * Fexios
 * @desc Fetch based HTTP client with similar API to axios for browser and Node.js
 *
 * @license MIT
 * @author dragon-fish <dragon-fish@qq.com>
 */
class L {
  constructor(t = {}) {
    this.baseConfigs = t, this.hooks = [], this.DEFAULT_CONFIGS = {
      baseURL: "",
      timeout: 60 * 1e3,
      credentials: "same-origin",
      headers: {},
      query: {},
      responseType: "json"
    }, this.ALL_METHODS = [
      "get",
      "post",
      "put",
      "patch",
      "delete",
      "head",
      "options",
      "trace"
    ], this.METHODS_WITHOUT_BODY = [
      "get",
      "head",
      "options",
      "trace"
    ], this.interceptors = {
      request: this.createInterceptor("beforeRequest"),
      response: this.createInterceptor("afterResponse")
    }, this.create = L.create, this.ALL_METHODS.forEach(this.createMethodShortcut.bind(this));
  }
  async request(t, s) {
    var n, r, o, a;
    let i = s = s || {};
    i.url = t.toString(), i = await this.emit("beforeInit", i);
    const c = s.baseURL || this.baseConfigs.baseURL || ((n = globalThis.location) == null ? void 0 : n.href), f = c ? new URL(c, (r = globalThis.location) == null ? void 0 : r.href) : void 0, l = new URL(i.url.toString(), f);
    if (i.url = l.href, i.baseURL = f ? f.href : l.origin, i.headers = this.mergeHeaders(
      this.baseConfigs.headers,
      s.headers
    ), i.query = this.mergeQuery(
      this.baseConfigs.query,
      l.searchParams,
      s.query
    ), l.search = new URLSearchParams(i.query).toString(), i.url = l.toString(), this.METHODS_WITHOUT_BODY.includes(
      (o = i.method) == null ? void 0 : o.toLocaleLowerCase()
    ) && i.body)
      throw new m(
        "BODY_NOT_ALLOWED",
        `Request method "${i.method}" does not allow body`
      );
    i = await this.emit("beforeRequest", i);
    let u;
    typeof i.body < "u" && i.body !== null && (i.body instanceof Blob || i.body instanceof FormData || i.body instanceof URLSearchParams ? u = i.body : typeof i.body == "object" ? (u = JSON.stringify(i.body), i.headers["content-type"] = "application/json; charset=UTF-8") : u = i.body), !((a = s.headers) != null && a["content-type"]) && u && (u instanceof FormData || u instanceof URLSearchParams ? typeof u == "string" && typeof i.body == "object" ? i.headers["content-type"] = "application/json; charset=UTF-8" : u instanceof Blob && (i.headers["content-type"] = u.type) : delete i.headers["content-type"]), i.body = u, i = await this.emit("afterBodyTransformed", i);
    const p = i.abortController || globalThis.AbortController ? new AbortController() : void 0, Ie = new Request(i.url, {
      method: i.method || "GET",
      credentials: i.credentials,
      headers: i.headers,
      body: i.body,
      signal: p == null ? void 0 : p.signal
    });
    i.rawRequest = Ie, i = await this.emit("beforeActualFetch", i);
    const ne = i.timeout || this.baseConfigs.timeout || 60 * 1e3, Oe = setTimeout(() => {
      if (p == null || p.abort(), !p)
        throw new m(
          "TIMEOUT",
          `Request timed out after ${ne}ms`,
          i
        );
    }, ne), oe = await fetch(i.rawRequest).catch((De) => {
      throw new m("NETWORK_ERROR", De.message, i);
    }).finally(() => {
      clearTimeout(Oe);
    });
    return i.rawResponse = oe, i.response = await pt(oe, i.responseType), i.data = i.response.data, i.headers = i.response.headers, this.emit("afterResponse", i);
  }
  mergeQuery(t, ...s) {
    const n = new URLSearchParams(t);
    for (const r of s)
      new URLSearchParams(r).forEach((o, a) => {
        n.set(a, o);
      });
    return Object.fromEntries(n);
  }
  mergeHeaders(t, ...s) {
    const n = {}, r = new Headers(t);
    for (const o of s)
      new Headers(o).forEach((a, i) => {
        r.set(i, a);
      });
    return r.forEach((o, a) => {
      n[a] = o;
    }), n;
  }
  async emit(t, s) {
    const n = this.hooks.filter((r) => r.event === t);
    try {
      let r = 0;
      for (const o of n) {
        const a = `${t}#${o.action.name || r}`, i = Symbol("FexiosHookContext");
        s.__hook_symbol__ = i;
        const c = await o.action.bind(this)(s);
        if (s.__hook_symbol__ !== i)
          throw new m(
            "HOOK_CONTEXT_CHANGED",
            `Hook "${a}" should not override the original FexiosContext object.`
          );
        if (c === !1)
          throw new m(
            "ABORTED_BY_HOOK",
            `Request aborted by hook "${a}"`,
            s
          );
        if (typeof c == "object" && c.__hook_symbol__ === i)
          s = c;
        else {
          const f = globalThis["".concat("console")];
          try {
            throw new m(
              "UNEXPECTED_HOOK_RETURN",
              `Hook "${a}" should return the original FexiosContext or return false to abort the request, but got "${c}".`
            );
          } catch (l) {
            f.warn(l.stack || l);
          }
        }
        delete s.__hook_symbol__, r++;
      }
    } catch (r) {
      return Promise.reject(r);
    }
    return s;
  }
  on(t, s, n = !1) {
    if (typeof s != "function")
      throw new m(
        "INVALID_HOOK_CALLBACK",
        `Hook "${s}" should be a function, but got "${typeof s}"`
      );
    return this.hooks[n ? "unshift" : "push"]({
      event: t,
      action: s
    }), this;
  }
  createInterceptor(t) {
    return {
      handlers: () => this.hooks.filter((s) => s.event === t).map((s) => s.action),
      use: (s, n = !1) => this.on(t, s, n),
      clear: () => {
        this.hooks = this.hooks.filter((s) => s.event !== t);
      }
    };
  }
  createMethodShortcut(t) {
    return Object.defineProperty(this, t, {
      value: (s, n, r) => (this.METHODS_WITHOUT_BODY.includes(
        t.toLocaleLowerCase()
      ) ? r = n : (r = r || {}, r.body = n), this.request(s, {
        ...r,
        method: t
      }))
    }), this;
  }
  extends(t) {
    const s = new L({ ...this.baseConfigs, ...t });
    return s.hooks = [...this.hooks], s;
  }
  static create(t) {
    return new L(t);
  }
}
class m extends Error {
  constructor(t, s, n) {
    super(s), this.code = t, this.context = n, this.name = "FexiosError";
  }
}
class dt extends m {
  constructor(t, s) {
    super(s.statusText, t), this.response = s, this.name = "FexiosResponseError";
  }
}
async function pt(e, t = "json") {
  let s;
  t === "blob" && (s = await e.clone().blob().catch(() => {
  })), s || (s = await e.clone().json().catch(() => e.clone().text()));
  const n = {
    rawResponse: e,
    data: s,
    ok: e.ok,
    status: e.status,
    statusText: e.statusText,
    headers: e.headers
  };
  if (!e.ok)
    throw new dt(
      `Request failed with status code ${e.status}`,
      n
    );
  return n;
}
Se();
function Se(e) {
  return L.create(e);
}
typeof window < "u" && (window.fexios = Se());
/**
 * MediaWiki Api for Axios
 * Provides the API call methods similar to `mw.Api` at non-mw environments
 *
 * @author Dragon-Fish <dragon-fish@qq.com>
 * @license MIT
 */
class y {
  constructor(t, s) {
    var n, r;
    if (this.cookies = {}, !t && typeof window == "object" && window.mediaWiki) {
      const { wgServer: o, wgScriptPath: a } = ((r = (n = window.mediaWiki) == null ? void 0 : n.config) == null ? void 0 : r.get(["wgServer", "wgScriptPath"])) || {};
      typeof o == "string" && typeof a == "string" && (t = `${o}${a}/api.php`);
    }
    if (typeof t != "string")
      throw new Error("baseURL is undefined");
    this.baseURL = G(t), this.tokens = {}, this.defaultParamsRef = G({}), this.defaultOptionsRef = G({}), this.defaultParams = {
      action: "query",
      errorformat: "plaintext",
      format: "json",
      formatversion: 2
    }, this.defaultOptions = s || {}, this.requestHandlerRef = ht(() => {
      const o = y.createRequestHandler(this.baseURL.value, {
        ...this.defaultOptions,
        query: this.defaultParams
      });
      return "document" in globalThis || (o.interceptors.request.use((a) => (a.headers = a.headers || {}, a.headers.cookie = Object.keys(this.cookies).map((i) => `${i}=${this.cookies[i]}`).join(";"), a)), o.interceptors.response.use((a) => {
        const i = a.rawResponse.headers.get(
          "set-cookie"
        ), c = i == null ? void 0 : i.split(",").map((f) => f.trim());
        return c == null || c.forEach((f) => {
          const [l, ...u] = f.split(";")[0].split("=");
          this.cookies[l] = u.join("=");
        }), a;
      })), o;
    });
  }
  static normalizeParamValue(t) {
    return Array.isArray(t) ? t.join("|") : typeof t == "boolean" ? t ? "1" : void 0 : typeof t == "number" ? "" + t : t;
  }
  static createRequestHandler(t, s = {}) {
    const n = new L(s);
    return n.baseConfigs.baseURL = t, n.on("beforeInit", (r) => {
      var o;
      if (((o = r.method) == null ? void 0 : o.toLowerCase()) !== "post")
        return r;
      if (typeof r.body == "object" && r.body !== null && !(r.body instanceof URLSearchParams) && !(r.body instanceof FormData)) {
        const a = r.body;
        Object.keys(a).forEach((i) => {
          const c = y.normalizeParamValue(a[i]);
          typeof c > "u" || c === null ? delete a[i] : c !== a[i] && (a[i] = c);
        }), r.body = new URLSearchParams(r.body);
      }
      if (globalThis.FormData && r.body instanceof FormData || r.body instanceof URLSearchParams) {
        const a = r.body;
        a.forEach((c, f) => {
          const l = y.normalizeParamValue(c);
          typeof l > "u" || l === null ? a.delete(f) : l !== c && a.set(f, l);
        });
        const i = new URLSearchParams(r.query);
        !i.has("format") && i.set("format", "" + (a.get("format") || "json")), !i.has("formatversion") && i.set(
          "formatversion",
          "" + (a.get("formatversion") || "2")
        ), a.has("origin") && i.set("origin", "" + a.get("origin")), r.query = Object.fromEntries(i), a.has("action") && (r.query.action = "" + a.get("action"));
      }
      return r;
    }), n.on("beforeInit", (r) => {
      r.query = r.query;
      for (const o in r.query) {
        const a = y.normalizeParamValue(r.query[o]);
        typeof a > "u" || a === null ? delete r.query[o] : a !== r.query[o] && (r.query[o] = "" + a);
      }
      return r;
    }), n.on("beforeRequest", (r) => {
      const o = new URL(r.url);
      if (o.searchParams.has("origin")) {
        const a = encodeURIComponent(
          o.searchParams.get("origin") || ""
        ).replace(/\./g, "%2E");
        r.query = {}, o.searchParams.delete("origin"), r.url = `${o}${o.search ? "&" : "?"}origin=${a}`;
      }
      return r;
    }), n;
  }
  /** Syntactic Sugar */
  // request handler
  get request() {
    return this.requestHandlerRef.value;
  }
  // userOptions
  get defaultOptions() {
    return this.defaultOptionsRef.value;
  }
  set defaultOptions(t) {
    this.defaultOptionsRef.value = t;
  }
  // defaultParams
  get defaultParams() {
    return this.defaultParamsRef.value;
  }
  set defaultParams(t) {
    this.defaultParamsRef.value = t;
  }
  /** Base methods encapsulation */
  get(t, s) {
    return this.request.get("", {
      query: t,
      ...s
    });
  }
  post(t, s) {
    return this.request.post("", t, s);
  }
  async login(t, s, n, r) {
    var a, i, c, f, l;
    if (this.defaultOptions.credentials = "include", r = r || {}, r.retry ?? (r.retry = 3), r.retry < 1)
      throw new I(
        "LOGIN_RETRY_LIMIT_EXCEEDED",
        "The limit of the number of times to automatically re-login has been exceeded"
      );
    let o;
    try {
      const u = await this.postWithToken(
        "login",
        {
          action: "login",
          lgname: t,
          lgpassword: s,
          ...n
        },
        { tokenName: "lgtoken", ...r }
      );
      if ((a = u == null ? void 0 : u.data) != null && a.login)
        o = u.data;
      else
        throw u;
    } catch (u) {
      if (u instanceof I)
        throw u;
      if ((u == null ? void 0 : u.ok) === !1)
        return this.login(t, s, n, {
          ...r,
          noCache: !0,
          retry: r.retry - 1
        });
      throw new I(
        "HTTP_ERROR",
        "The server returns an error, but it doesn't seem to be caused by MediaWiki",
        u
      );
    }
    if (((i = o == null ? void 0 : o.login) == null ? void 0 : i.result) !== "Success")
      throw new I(
        "LOGIN_FAILED",
        ((f = (c = o == null ? void 0 : o.login) == null ? void 0 : c.reason) == null ? void 0 : f.text) || ((l = o == null ? void 0 : o.login) == null ? void 0 : l.result) || "Login failed with unknown reason",
        o
      );
    return o.login;
  }
  async getUserInfo() {
    var s;
    const { data: t } = await this.get({
      action: "query",
      meta: "userinfo",
      uiprop: ["groups", "rights", "blockinfo"]
    });
    return (s = t == null ? void 0 : t.query) == null ? void 0 : s.userinfo;
  }
  /** Token Handler */
  async getTokens(t = ["csrf"]) {
    this.defaultOptions.credentials = "include";
    const { data: s } = await this.get({
      action: "query",
      meta: "tokens",
      type: t
    });
    return this.tokens = { ...this.tokens, ...s.query.tokens }, this.tokens;
  }
  async token(t = "csrf", s = !1) {
    return (!this.tokens[`${t}token`] || s) && (delete this.tokens[`${t}token`], await this.getTokens([t])), this.tokens[`${t}token`];
  }
  async postWithToken(t, s, n) {
    const { tokenName: r = "token", retry: o = 3, noCache: a = !1 } = n || {};
    if (o < 1)
      throw new I(
        "TOKEN_RETRY_LIMIT_EXCEEDED",
        "The limit of the number of times to automatically re-acquire the token has been exceeded"
      );
    const i = await this.token(t, a), c = () => this.postWithToken(t, s, {
      tokenName: r,
      retry: o - 1,
      noCache: !0
    });
    return this.post({
      [r]: i,
      ...s
    }).then((f) => {
      const l = f.data;
      return y.isBadTokenError(l) ? c() : f;
    }).catch((f) => {
      const l = f.data;
      if (y.isBadTokenError(l) || (f == null ? void 0 : f.ok) === !1)
        return c();
      if (typeof l == "object" && l !== null)
        return Promise.reject(l);
      throw new I(
        "HTTP_ERROR",
        "The server returns an error, but it doesn’t seem to be caused by MediaWiki",
        f
      );
    });
  }
  postWithEditToken(t) {
    return this.postWithToken("csrf", t);
  }
  static isBadTokenError(t) {
    var s, n, r;
    return ((s = t == null ? void 0 : t.error) == null ? void 0 : s.code) === "badtoken" || ((n = t == null ? void 0 : t.errors) == null ? void 0 : n.some((o) => o.code === "badtoken")) || ["NeedToken", "WrongToken"].includes((r = t == null ? void 0 : t.login) == null ? void 0 : r.result);
  }
  async getMessages(t, s = "zh", n) {
    const { data: r } = await this.get({
      action: "query",
      meta: "allmessages",
      ammessages: t,
      amlang: s,
      ...n
    }), o = {};
    return r.query.allmessages.forEach(function(a) {
      a.missing || (o[a.name] = a.content);
    }), o;
  }
  async parseWikitext(t, s, n, r) {
    const { data: o } = await this.post(
      {
        action: "parse",
        title: s,
        text: t,
        ...n
      },
      r
    );
    return o.parse.text;
  }
}
class _t extends y {
  constructor(t, s) {
    super(t, {
      credentials: "include",
      ...s
    }), this.defaultParams.origin = location.origin;
  }
}
var bt = /* @__PURE__ */ ((e) => (e.HTTP_ERROR = "HTTP_ERROR", e.LOGIN_FAILED = "LOGIN_FAILED", e.LOGIN_RETRY_LIMIT_EXCEEDED = "LOGIN_RETRY_LIMIT_EXCEEDED", e.TOKEN_RETRY_LIMIT_EXCEEDED = "TOKEN_RETRY_LIMIT_EXCEEDED", e))(bt || {});
class I extends Error {
  constructor(t, s = "", n) {
    super(), this.code = t, this.message = s, this.cause = n, this.name = "WikiSaikouError";
  }
}
export {
  _t as ForeignApi,
  y as MediaWikiApi,
  _t as MediaWikiForeignApi,
  y as MwApi,
  I as WikiSaikouError,
  bt as WikiSaikouErrorCode,
  y as default
};
//# sourceMappingURL=index.js.map

{"version":3,"file":"index.iife.js","sources":["../node_modules/.pnpm/@vue+shared@3.5.8/node_modules/@vue/shared/dist/shared.esm-bundler.js","../node_modules/.pnpm/@vue+reactivity@3.5.8/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js","../node_modules/.pnpm/fexios@1.7.1/node_modules/fexios/dist/index.js","../src/index.ts"],"sourcesContent":["/**\n* @vue/shared v3.5.8\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\n/*! #__NO_SIDE_EFFECTS__ */\n// @__NO_SIDE_EFFECTS__\nfunction makeMap(str) {\n  const map = /* @__PURE__ */ Object.create(null);\n  for (const key of str.split(\",\")) map[key] = 1;\n  return (val) => val in map;\n}\n\nconst EMPTY_OBJ = !!(process.env.NODE_ENV !== \"production\") ? Object.freeze({}) : {};\nconst EMPTY_ARR = !!(process.env.NODE_ENV !== \"production\") ? Object.freeze([]) : [];\nconst NOOP = () => {\n};\nconst NO = () => false;\nconst isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter\n(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);\nconst isModelListener = (key) => key.startsWith(\"onUpdate:\");\nconst extend = Object.assign;\nconst remove = (arr, el) => {\n  const i = arr.indexOf(el);\n  if (i > -1) {\n    arr.splice(i, 1);\n  }\n};\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\nconst isArray = Array.isArray;\nconst isMap = (val) => toTypeString(val) === \"[object Map]\";\nconst isSet = (val) => toTypeString(val) === \"[object Set]\";\nconst isDate = (val) => toTypeString(val) === \"[object Date]\";\nconst isRegExp = (val) => toTypeString(val) === \"[object RegExp]\";\nconst isFunction = (val) => typeof val === \"function\";\nconst isString = (val) => typeof val === \"string\";\nconst isSymbol = (val) => typeof val === \"symbol\";\nconst isObject = (val) => val !== null && typeof val === \"object\";\nconst isPromise = (val) => {\n  return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);\n};\nconst objectToString = Object.prototype.toString;\nconst toTypeString = (value) => objectToString.call(value);\nconst toRawType = (value) => {\n  return toTypeString(value).slice(8, -1);\n};\nconst isPlainObject = (val) => toTypeString(val) === \"[object Object]\";\nconst isIntegerKey = (key) => isString(key) && key !== \"NaN\" && key[0] !== \"-\" && \"\" + parseInt(key, 10) === key;\nconst isReservedProp = /* @__PURE__ */ makeMap(\n  // the leading comma is intentional so empty string \"\" is also included\n  \",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted\"\n);\nconst isBuiltInDirective = /* @__PURE__ */ makeMap(\n  \"bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo\"\n);\nconst cacheStringFunction = (fn) => {\n  const cache = /* @__PURE__ */ Object.create(null);\n  return (str) => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n};\nconst camelizeRE = /-(\\w)/g;\nconst camelize = cacheStringFunction(\n  (str) => {\n    return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : \"\");\n  }\n);\nconst hyphenateRE = /\\B([A-Z])/g;\nconst hyphenate = cacheStringFunction(\n  (str) => str.replace(hyphenateRE, \"-$1\").toLowerCase()\n);\nconst capitalize = cacheStringFunction((str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n});\nconst toHandlerKey = cacheStringFunction(\n  (str) => {\n    const s = str ? `on${capitalize(str)}` : ``;\n    return s;\n  }\n);\nconst hasChanged = (value, oldValue) => !Object.is(value, oldValue);\nconst invokeArrayFns = (fns, ...arg) => {\n  for (let i = 0; i < fns.length; i++) {\n    fns[i](...arg);\n  }\n};\nconst def = (obj, key, value, writable = false) => {\n  Object.defineProperty(obj, key, {\n    configurable: true,\n    enumerable: false,\n    writable,\n    value\n  });\n};\nconst looseToNumber = (val) => {\n  const n = parseFloat(val);\n  return isNaN(n) ? val : n;\n};\nconst toNumber = (val) => {\n  const n = isString(val) ? Number(val) : NaN;\n  return isNaN(n) ? val : n;\n};\nlet _globalThis;\nconst getGlobalThis = () => {\n  return _globalThis || (_globalThis = typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {});\n};\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/;\nfunction genPropsAccessExp(name) {\n  return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;\n}\n\nconst PatchFlags = {\n  \"TEXT\": 1,\n  \"1\": \"TEXT\",\n  \"CLASS\": 2,\n  \"2\": \"CLASS\",\n  \"STYLE\": 4,\n  \"4\": \"STYLE\",\n  \"PROPS\": 8,\n  \"8\": \"PROPS\",\n  \"FULL_PROPS\": 16,\n  \"16\": \"FULL_PROPS\",\n  \"NEED_HYDRATION\": 32,\n  \"32\": \"NEED_HYDRATION\",\n  \"STABLE_FRAGMENT\": 64,\n  \"64\": \"STABLE_FRAGMENT\",\n  \"KEYED_FRAGMENT\": 128,\n  \"128\": \"KEYED_FRAGMENT\",\n  \"UNKEYED_FRAGMENT\": 256,\n  \"256\": \"UNKEYED_FRAGMENT\",\n  \"NEED_PATCH\": 512,\n  \"512\": \"NEED_PATCH\",\n  \"DYNAMIC_SLOTS\": 1024,\n  \"1024\": \"DYNAMIC_SLOTS\",\n  \"DEV_ROOT_FRAGMENT\": 2048,\n  \"2048\": \"DEV_ROOT_FRAGMENT\",\n  \"CACHED\": -1,\n  \"-1\": \"CACHED\",\n  \"BAIL\": -2,\n  \"-2\": \"BAIL\"\n};\nconst PatchFlagNames = {\n  [1]: `TEXT`,\n  [2]: `CLASS`,\n  [4]: `STYLE`,\n  [8]: `PROPS`,\n  [16]: `FULL_PROPS`,\n  [32]: `NEED_HYDRATION`,\n  [64]: `STABLE_FRAGMENT`,\n  [128]: `KEYED_FRAGMENT`,\n  [256]: `UNKEYED_FRAGMENT`,\n  [512]: `NEED_PATCH`,\n  [1024]: `DYNAMIC_SLOTS`,\n  [2048]: `DEV_ROOT_FRAGMENT`,\n  [-1]: `HOISTED`,\n  [-2]: `BAIL`\n};\n\nconst ShapeFlags = {\n  \"ELEMENT\": 1,\n  \"1\": \"ELEMENT\",\n  \"FUNCTIONAL_COMPONENT\": 2,\n  \"2\": \"FUNCTIONAL_COMPONENT\",\n  \"STATEFUL_COMPONENT\": 4,\n  \"4\": \"STATEFUL_COMPONENT\",\n  \"TEXT_CHILDREN\": 8,\n  \"8\": \"TEXT_CHILDREN\",\n  \"ARRAY_CHILDREN\": 16,\n  \"16\": \"ARRAY_CHILDREN\",\n  \"SLOTS_CHILDREN\": 32,\n  \"32\": \"SLOTS_CHILDREN\",\n  \"TELEPORT\": 64,\n  \"64\": \"TELEPORT\",\n  \"SUSPENSE\": 128,\n  \"128\": \"SUSPENSE\",\n  \"COMPONENT_SHOULD_KEEP_ALIVE\": 256,\n  \"256\": \"COMPONENT_SHOULD_KEEP_ALIVE\",\n  \"COMPONENT_KEPT_ALIVE\": 512,\n  \"512\": \"COMPONENT_KEPT_ALIVE\",\n  \"COMPONENT\": 6,\n  \"6\": \"COMPONENT\"\n};\n\nconst SlotFlags = {\n  \"STABLE\": 1,\n  \"1\": \"STABLE\",\n  \"DYNAMIC\": 2,\n  \"2\": \"DYNAMIC\",\n  \"FORWARDED\": 3,\n  \"3\": \"FORWARDED\"\n};\nconst slotFlagsText = {\n  [1]: \"STABLE\",\n  [2]: \"DYNAMIC\",\n  [3]: \"FORWARDED\"\n};\n\nconst GLOBALS_ALLOWED = \"Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol\";\nconst isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);\nconst isGloballyWhitelisted = isGloballyAllowed;\n\nconst range = 2;\nfunction generateCodeFrame(source, start = 0, end = source.length) {\n  start = Math.max(0, Math.min(start, source.length));\n  end = Math.max(0, Math.min(end, source.length));\n  if (start > end) return \"\";\n  let lines = source.split(/(\\r?\\n)/);\n  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);\n  lines = lines.filter((_, idx) => idx % 2 === 0);\n  let count = 0;\n  const res = [];\n  for (let i = 0; i < lines.length; i++) {\n    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);\n    if (count >= start) {\n      for (let j = i - range; j <= i + range || end > count; j++) {\n        if (j < 0 || j >= lines.length) continue;\n        const line = j + 1;\n        res.push(\n          `${line}${\" \".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`\n        );\n        const lineLength = lines[j].length;\n        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;\n        if (j === i) {\n          const pad = start - (count - (lineLength + newLineSeqLength));\n          const length = Math.max(\n            1,\n            end > count ? lineLength - pad : end - start\n          );\n          res.push(`   |  ` + \" \".repeat(pad) + \"^\".repeat(length));\n        } else if (j > i) {\n          if (end > count) {\n            const length = Math.max(Math.min(end - count, lineLength), 1);\n            res.push(`   |  ` + \"^\".repeat(length));\n          }\n          count += lineLength + newLineSeqLength;\n        }\n      }\n      break;\n    }\n  }\n  return res.join(\"\\n\");\n}\n\nfunction normalizeStyle(value) {\n  if (isArray(value)) {\n    const res = {};\n    for (let i = 0; i < value.length; i++) {\n      const item = value[i];\n      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);\n      if (normalized) {\n        for (const key in normalized) {\n          res[key] = normalized[key];\n        }\n      }\n    }\n    return res;\n  } else if (isString(value) || isObject(value)) {\n    return value;\n  }\n}\nconst listDelimiterRE = /;(?![^(]*\\))/g;\nconst propertyDelimiterRE = /:([^]+)/;\nconst styleCommentRE = /\\/\\*[^]*?\\*\\//g;\nfunction parseStringStyle(cssText) {\n  const ret = {};\n  cssText.replace(styleCommentRE, \"\").split(listDelimiterRE).forEach((item) => {\n    if (item) {\n      const tmp = item.split(propertyDelimiterRE);\n      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return ret;\n}\nfunction stringifyStyle(styles) {\n  let ret = \"\";\n  if (!styles || isString(styles)) {\n    return ret;\n  }\n  for (const key in styles) {\n    const value = styles[key];\n    if (isString(value) || typeof value === \"number\") {\n      const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\n      ret += `${normalizedKey}:${value};`;\n    }\n  }\n  return ret;\n}\nfunction normalizeClass(value) {\n  let res = \"\";\n  if (isString(value)) {\n    res = value;\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      const normalized = normalizeClass(value[i]);\n      if (normalized) {\n        res += normalized + \" \";\n      }\n    }\n  } else if (isObject(value)) {\n    for (const name in value) {\n      if (value[name]) {\n        res += name + \" \";\n      }\n    }\n  }\n  return res.trim();\n}\nfunction normalizeProps(props) {\n  if (!props) return null;\n  let { class: klass, style } = props;\n  if (klass && !isString(klass)) {\n    props.class = normalizeClass(klass);\n  }\n  if (style) {\n    props.style = normalizeStyle(style);\n  }\n  return props;\n}\n\nconst HTML_TAGS = \"html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot\";\nconst SVG_TAGS = \"svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view\";\nconst MATH_TAGS = \"annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics\";\nconst VOID_TAGS = \"area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr\";\nconst isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);\nconst isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);\nconst isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);\nconst isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);\n\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\nconst isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);\nconst isBooleanAttr = /* @__PURE__ */ makeMap(\n  specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`\n);\nfunction includeBooleanAttr(value) {\n  return !!value || value === \"\";\n}\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\nconst attrValidationCache = {};\nfunction isSSRSafeAttrName(name) {\n  if (attrValidationCache.hasOwnProperty(name)) {\n    return attrValidationCache[name];\n  }\n  const isUnsafe = unsafeAttrCharRE.test(name);\n  if (isUnsafe) {\n    console.error(`unsafe attribute name: ${name}`);\n  }\n  return attrValidationCache[name] = !isUnsafe;\n}\nconst propsToAttrMap = {\n  acceptCharset: \"accept-charset\",\n  className: \"class\",\n  htmlFor: \"for\",\n  httpEquiv: \"http-equiv\"\n};\nconst isKnownHtmlAttr = /* @__PURE__ */ makeMap(\n  `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`\n);\nconst isKnownSvgAttr = /* @__PURE__ */ makeMap(\n  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`\n);\nconst isKnownMathMLAttr = /* @__PURE__ */ makeMap(\n  `accent,accentunder,actiontype,align,alignmentscope,altimg,altimg-height,altimg-valign,altimg-width,alttext,bevelled,close,columnsalign,columnlines,columnspan,denomalign,depth,dir,display,displaystyle,encoding,equalcolumns,equalrows,fence,fontstyle,fontweight,form,frame,framespacing,groupalign,height,href,id,indentalign,indentalignfirst,indentalignlast,indentshift,indentshiftfirst,indentshiftlast,indextype,justify,largetop,largeop,lquote,lspace,mathbackground,mathcolor,mathsize,mathvariant,maxsize,minlabelspacing,mode,other,overflow,position,rowalign,rowlines,rowspan,rquote,rspace,scriptlevel,scriptminsize,scriptsizemultiplier,selection,separator,separators,shift,side,src,stackalign,stretchy,subscriptshift,superscriptshift,symmetric,voffset,width,widths,xlink:href,xlink:show,xlink:type,xmlns`\n);\nfunction isRenderableAttrValue(value) {\n  if (value == null) {\n    return false;\n  }\n  const type = typeof value;\n  return type === \"string\" || type === \"number\" || type === \"boolean\";\n}\n\nconst escapeRE = /[\"'&<>]/;\nfunction escapeHtml(string) {\n  const str = \"\" + string;\n  const match = escapeRE.exec(str);\n  if (!match) {\n    return str;\n  }\n  let html = \"\";\n  let escaped;\n  let index;\n  let lastIndex = 0;\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34:\n        escaped = \"&quot;\";\n        break;\n      case 38:\n        escaped = \"&amp;\";\n        break;\n      case 39:\n        escaped = \"&#39;\";\n        break;\n      case 60:\n        escaped = \"&lt;\";\n        break;\n      case 62:\n        escaped = \"&gt;\";\n        break;\n      default:\n        continue;\n    }\n    if (lastIndex !== index) {\n      html += str.slice(lastIndex, index);\n    }\n    lastIndex = index + 1;\n    html += escaped;\n  }\n  return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\n}\nconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\nfunction escapeHtmlComment(src) {\n  return src.replace(commentStripRE, \"\");\n}\nconst cssVarNameEscapeSymbolsRE = /[ !\"#$%&'()*+,./:;<=>?@[\\\\\\]^`{|}~]/g;\nfunction getEscapedCssVarName(key, doubleEscape) {\n  return key.replace(\n    cssVarNameEscapeSymbolsRE,\n    (s) => doubleEscape ? s === '\"' ? '\\\\\\\\\\\\\"' : `\\\\\\\\${s}` : `\\\\${s}`\n  );\n}\n\nfunction looseCompareArrays(a, b) {\n  if (a.length !== b.length) return false;\n  let equal = true;\n  for (let i = 0; equal && i < a.length; i++) {\n    equal = looseEqual(a[i], b[i]);\n  }\n  return equal;\n}\nfunction looseEqual(a, b) {\n  if (a === b) return true;\n  let aValidType = isDate(a);\n  let bValidType = isDate(b);\n  if (aValidType || bValidType) {\n    return aValidType && bValidType ? a.getTime() === b.getTime() : false;\n  }\n  aValidType = isSymbol(a);\n  bValidType = isSymbol(b);\n  if (aValidType || bValidType) {\n    return a === b;\n  }\n  aValidType = isArray(a);\n  bValidType = isArray(b);\n  if (aValidType || bValidType) {\n    return aValidType && bValidType ? looseCompareArrays(a, b) : false;\n  }\n  aValidType = isObject(a);\n  bValidType = isObject(b);\n  if (aValidType || bValidType) {\n    if (!aValidType || !bValidType) {\n      return false;\n    }\n    const aKeysCount = Object.keys(a).length;\n    const bKeysCount = Object.keys(b).length;\n    if (aKeysCount !== bKeysCount) {\n      return false;\n    }\n    for (const key in a) {\n      const aHasKey = a.hasOwnProperty(key);\n      const bHasKey = b.hasOwnProperty(key);\n      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n  }\n  return String(a) === String(b);\n}\nfunction looseIndexOf(arr, val) {\n  return arr.findIndex((item) => looseEqual(item, val));\n}\n\nconst isRef = (val) => {\n  return !!(val && val[\"__v_isRef\"] === true);\n};\nconst toDisplayString = (val) => {\n  return isString(val) ? val : val == null ? \"\" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? isRef(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);\n};\nconst replacer = (_key, val) => {\n  if (isRef(val)) {\n    return replacer(_key, val.value);\n  } else if (isMap(val)) {\n    return {\n      [`Map(${val.size})`]: [...val.entries()].reduce(\n        (entries, [key, val2], i) => {\n          entries[stringifySymbol(key, i) + \" =>\"] = val2;\n          return entries;\n        },\n        {}\n      )\n    };\n  } else if (isSet(val)) {\n    return {\n      [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))\n    };\n  } else if (isSymbol(val)) {\n    return stringifySymbol(val);\n  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\n    return String(val);\n  }\n  return val;\n};\nconst stringifySymbol = (v, i = \"\") => {\n  var _a;\n  return (\n    // Symbol.description in es2019+ so we need to cast here to pass\n    // the lib: es2016 check\n    isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v\n  );\n};\n\nexport { EMPTY_ARR, EMPTY_OBJ, NO, NOOP, PatchFlagNames, PatchFlags, ShapeFlags, SlotFlags, camelize, capitalize, cssVarNameEscapeSymbolsRE, def, escapeHtml, escapeHtmlComment, extend, genPropsAccessExp, generateCodeFrame, getEscapedCssVarName, getGlobalThis, hasChanged, hasOwn, hyphenate, includeBooleanAttr, invokeArrayFns, isArray, isBooleanAttr, isBuiltInDirective, isDate, isFunction, isGloballyAllowed, isGloballyWhitelisted, isHTMLTag, isIntegerKey, isKnownHtmlAttr, isKnownMathMLAttr, isKnownSvgAttr, isMap, isMathMLTag, isModelListener, isObject, isOn, isPlainObject, isPromise, isRegExp, isRenderableAttrValue, isReservedProp, isSSRSafeAttrName, isSVGTag, isSet, isSpecialBooleanAttr, isString, isSymbol, isVoidTag, looseEqual, looseIndexOf, looseToNumber, makeMap, normalizeClass, normalizeProps, normalizeStyle, objectToString, parseStringStyle, propsToAttrMap, remove, slotFlagsText, stringifyStyle, toDisplayString, toHandlerKey, toNumber, toRawType, toTypeString };\n","/**\n* @vue/reactivity v3.5.8\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\nimport { hasChanged, extend, isArray, isIntegerKey, isSymbol, isMap, hasOwn, isObject, makeMap, capitalize, toRawType, def, isFunction, EMPTY_OBJ, isSet, isPlainObject, NOOP, remove } from '@vue/shared';\n\nfunction warn(msg, ...args) {\n  console.warn(`[Vue warn] ${msg}`, ...args);\n}\n\nlet activeEffectScope;\nclass EffectScope {\n  constructor(detached = false) {\n    this.detached = detached;\n    /**\n     * @internal\n     */\n    this._active = true;\n    /**\n     * @internal\n     */\n    this.effects = [];\n    /**\n     * @internal\n     */\n    this.cleanups = [];\n    this._isPaused = false;\n    this.parent = activeEffectScope;\n    if (!detached && activeEffectScope) {\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(\n        this\n      ) - 1;\n    }\n  }\n  get active() {\n    return this._active;\n  }\n  pause() {\n    if (this._active) {\n      this._isPaused = true;\n      let i, l;\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].pause();\n        }\n      }\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].pause();\n      }\n    }\n  }\n  /**\n   * Resumes the effect scope, including all child scopes and effects.\n   */\n  resume() {\n    if (this._active) {\n      if (this._isPaused) {\n        this._isPaused = false;\n        let i, l;\n        if (this.scopes) {\n          for (i = 0, l = this.scopes.length; i < l; i++) {\n            this.scopes[i].resume();\n          }\n        }\n        for (i = 0, l = this.effects.length; i < l; i++) {\n          this.effects[i].resume();\n        }\n      }\n    }\n  }\n  run(fn) {\n    if (this._active) {\n      const currentEffectScope = activeEffectScope;\n      try {\n        activeEffectScope = this;\n        return fn();\n      } finally {\n        activeEffectScope = currentEffectScope;\n      }\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(`cannot run an inactive effect scope.`);\n    }\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  on() {\n    activeEffectScope = this;\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  off() {\n    activeEffectScope = this.parent;\n  }\n  stop(fromParent) {\n    if (this._active) {\n      let i, l;\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].stop();\n      }\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\n        this.cleanups[i]();\n      }\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].stop(true);\n        }\n      }\n      if (!this.detached && this.parent && !fromParent) {\n        const last = this.parent.scopes.pop();\n        if (last && last !== this) {\n          this.parent.scopes[this.index] = last;\n          last.index = this.index;\n        }\n      }\n      this.parent = void 0;\n      this._active = false;\n    }\n  }\n}\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\nfunction onScopeDispose(fn, failSilently = false) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(\n      `onScopeDispose() is called when there is no active effect scope to be associated with.`\n    );\n  }\n}\n\nlet activeSub;\nconst EffectFlags = {\n  \"ACTIVE\": 1,\n  \"1\": \"ACTIVE\",\n  \"RUNNING\": 2,\n  \"2\": \"RUNNING\",\n  \"TRACKING\": 4,\n  \"4\": \"TRACKING\",\n  \"NOTIFIED\": 8,\n  \"8\": \"NOTIFIED\",\n  \"DIRTY\": 16,\n  \"16\": \"DIRTY\",\n  \"ALLOW_RECURSE\": 32,\n  \"32\": \"ALLOW_RECURSE\",\n  \"PAUSED\": 64,\n  \"64\": \"PAUSED\"\n};\nconst pausedQueueEffects = /* @__PURE__ */ new WeakSet();\nclass ReactiveEffect {\n  constructor(fn) {\n    this.fn = fn;\n    /**\n     * @internal\n     */\n    this.deps = void 0;\n    /**\n     * @internal\n     */\n    this.depsTail = void 0;\n    /**\n     * @internal\n     */\n    this.flags = 1 | 4;\n    /**\n     * @internal\n     */\n    this.next = void 0;\n    /**\n     * @internal\n     */\n    this.cleanup = void 0;\n    this.scheduler = void 0;\n    if (activeEffectScope && activeEffectScope.active) {\n      activeEffectScope.effects.push(this);\n    }\n  }\n  pause() {\n    this.flags |= 64;\n  }\n  resume() {\n    if (this.flags & 64) {\n      this.flags &= ~64;\n      if (pausedQueueEffects.has(this)) {\n        pausedQueueEffects.delete(this);\n        this.trigger();\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  notify() {\n    if (this.flags & 2 && !(this.flags & 32)) {\n      return;\n    }\n    if (!(this.flags & 8)) {\n      batch(this);\n    }\n  }\n  run() {\n    if (!(this.flags & 1)) {\n      return this.fn();\n    }\n    this.flags |= 2;\n    cleanupEffect(this);\n    prepareDeps(this);\n    const prevEffect = activeSub;\n    const prevShouldTrack = shouldTrack;\n    activeSub = this;\n    shouldTrack = true;\n    try {\n      return this.fn();\n    } finally {\n      if (!!(process.env.NODE_ENV !== \"production\") && activeSub !== this) {\n        warn(\n          \"Active effect was not restored correctly - this is likely a Vue internal bug.\"\n        );\n      }\n      cleanupDeps(this);\n      activeSub = prevEffect;\n      shouldTrack = prevShouldTrack;\n      this.flags &= ~2;\n    }\n  }\n  stop() {\n    if (this.flags & 1) {\n      for (let link = this.deps; link; link = link.nextDep) {\n        removeSub(link);\n      }\n      this.deps = this.depsTail = void 0;\n      cleanupEffect(this);\n      this.onStop && this.onStop();\n      this.flags &= ~1;\n    }\n  }\n  trigger() {\n    if (this.flags & 64) {\n      pausedQueueEffects.add(this);\n    } else if (this.scheduler) {\n      this.scheduler();\n    } else {\n      this.runIfDirty();\n    }\n  }\n  /**\n   * @internal\n   */\n  runIfDirty() {\n    if (isDirty(this)) {\n      this.run();\n    }\n  }\n  get dirty() {\n    return isDirty(this);\n  }\n}\nlet batchDepth = 0;\nlet batchedSub;\nfunction batch(sub) {\n  sub.flags |= 8;\n  sub.next = batchedSub;\n  batchedSub = sub;\n}\nfunction startBatch() {\n  batchDepth++;\n}\nfunction endBatch() {\n  if (--batchDepth > 0) {\n    return;\n  }\n  let error;\n  while (batchedSub) {\n    let e = batchedSub;\n    batchedSub = void 0;\n    while (e) {\n      const next = e.next;\n      e.next = void 0;\n      e.flags &= ~8;\n      if (e.flags & 1) {\n        try {\n          ;\n          e.trigger();\n        } catch (err) {\n          if (!error) error = err;\n        }\n      }\n      e = next;\n    }\n  }\n  if (error) throw error;\n}\nfunction prepareDeps(sub) {\n  for (let link = sub.deps; link; link = link.nextDep) {\n    link.version = -1;\n    link.prevActiveLink = link.dep.activeLink;\n    link.dep.activeLink = link;\n  }\n}\nfunction cleanupDeps(sub, fromComputed = false) {\n  let head;\n  let tail = sub.depsTail;\n  let link = tail;\n  while (link) {\n    const prev = link.prevDep;\n    if (link.version === -1) {\n      if (link === tail) tail = prev;\n      removeSub(link, fromComputed);\n      removeDep(link);\n    } else {\n      head = link;\n    }\n    link.dep.activeLink = link.prevActiveLink;\n    link.prevActiveLink = void 0;\n    link = prev;\n  }\n  sub.deps = head;\n  sub.depsTail = tail;\n}\nfunction isDirty(sub) {\n  for (let link = sub.deps; link; link = link.nextDep) {\n    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {\n      return true;\n    }\n  }\n  if (sub._dirty) {\n    return true;\n  }\n  return false;\n}\nfunction refreshComputed(computed) {\n  if (computed.flags & 4 && !(computed.flags & 16)) {\n    return;\n  }\n  computed.flags &= ~16;\n  if (computed.globalVersion === globalVersion) {\n    return;\n  }\n  computed.globalVersion = globalVersion;\n  const dep = computed.dep;\n  computed.flags |= 2;\n  if (dep.version > 0 && !computed.isSSR && computed.deps && !isDirty(computed)) {\n    computed.flags &= ~2;\n    return;\n  }\n  const prevSub = activeSub;\n  const prevShouldTrack = shouldTrack;\n  activeSub = computed;\n  shouldTrack = true;\n  try {\n    prepareDeps(computed);\n    const value = computed.fn(computed._value);\n    if (dep.version === 0 || hasChanged(value, computed._value)) {\n      computed._value = value;\n      dep.version++;\n    }\n  } catch (err) {\n    dep.version++;\n    throw err;\n  } finally {\n    activeSub = prevSub;\n    shouldTrack = prevShouldTrack;\n    cleanupDeps(computed, true);\n    computed.flags &= ~2;\n  }\n}\nfunction removeSub(link, fromComputed = false) {\n  const { dep, prevSub, nextSub } = link;\n  if (prevSub) {\n    prevSub.nextSub = nextSub;\n    link.prevSub = void 0;\n  }\n  if (nextSub) {\n    nextSub.prevSub = prevSub;\n    link.nextSub = void 0;\n  }\n  if (dep.subs === link) {\n    dep.subs = prevSub;\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") && dep.subsHead === link) {\n    dep.subsHead = nextSub;\n  }\n  if (!dep.subs) {\n    if (dep.computed) {\n      dep.computed.flags &= ~4;\n      for (let l = dep.computed.deps; l; l = l.nextDep) {\n        removeSub(l, true);\n      }\n    } else if (dep.map && !fromComputed) {\n      dep.map.delete(dep.key);\n      if (!dep.map.size) targetMap.delete(dep.target);\n    }\n  }\n}\nfunction removeDep(link) {\n  const { prevDep, nextDep } = link;\n  if (prevDep) {\n    prevDep.nextDep = nextDep;\n    link.prevDep = void 0;\n  }\n  if (nextDep) {\n    nextDep.prevDep = prevDep;\n    link.nextDep = void 0;\n  }\n}\nfunction effect(fn, options) {\n  if (fn.effect instanceof ReactiveEffect) {\n    fn = fn.effect.fn;\n  }\n  const e = new ReactiveEffect(fn);\n  if (options) {\n    extend(e, options);\n  }\n  try {\n    e.run();\n  } catch (err) {\n    e.stop();\n    throw err;\n  }\n  const runner = e.run.bind(e);\n  runner.effect = e;\n  return runner;\n}\nfunction stop(runner) {\n  runner.effect.stop();\n}\nlet shouldTrack = true;\nconst trackStack = [];\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === void 0 ? true : last;\n}\nfunction onEffectCleanup(fn, failSilently = false) {\n  if (activeSub instanceof ReactiveEffect) {\n    activeSub.cleanup = fn;\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(\n      `onEffectCleanup() was called when there was no active effect to associate with.`\n    );\n  }\n}\nfunction cleanupEffect(e) {\n  const { cleanup } = e;\n  e.cleanup = void 0;\n  if (cleanup) {\n    const prevSub = activeSub;\n    activeSub = void 0;\n    try {\n      cleanup();\n    } finally {\n      activeSub = prevSub;\n    }\n  }\n}\n\nlet globalVersion = 0;\nclass Link {\n  constructor(sub, dep) {\n    this.sub = sub;\n    this.dep = dep;\n    this.version = dep.version;\n    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;\n  }\n}\nclass Dep {\n  constructor(computed) {\n    this.computed = computed;\n    this.version = 0;\n    /**\n     * Link between this dep and the current active effect\n     */\n    this.activeLink = void 0;\n    /**\n     * Doubly linked list representing the subscribing effects (tail)\n     */\n    this.subs = void 0;\n    /**\n     * For object property deps cleanup\n     */\n    this.target = void 0;\n    this.map = void 0;\n    this.key = void 0;\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      this.subsHead = void 0;\n    }\n  }\n  track(debugInfo) {\n    if (!activeSub || !shouldTrack || activeSub === this.computed) {\n      return;\n    }\n    let link = this.activeLink;\n    if (link === void 0 || link.sub !== activeSub) {\n      link = this.activeLink = new Link(activeSub, this);\n      if (!activeSub.deps) {\n        activeSub.deps = activeSub.depsTail = link;\n      } else {\n        link.prevDep = activeSub.depsTail;\n        activeSub.depsTail.nextDep = link;\n        activeSub.depsTail = link;\n      }\n      if (activeSub.flags & 4) {\n        addSub(link);\n      }\n    } else if (link.version === -1) {\n      link.version = this.version;\n      if (link.nextDep) {\n        const next = link.nextDep;\n        next.prevDep = link.prevDep;\n        if (link.prevDep) {\n          link.prevDep.nextDep = next;\n        }\n        link.prevDep = activeSub.depsTail;\n        link.nextDep = void 0;\n        activeSub.depsTail.nextDep = link;\n        activeSub.depsTail = link;\n        if (activeSub.deps === link) {\n          activeSub.deps = next;\n        }\n      }\n    }\n    if (!!(process.env.NODE_ENV !== \"production\") && activeSub.onTrack) {\n      activeSub.onTrack(\n        extend(\n          {\n            effect: activeSub\n          },\n          debugInfo\n        )\n      );\n    }\n    return link;\n  }\n  trigger(debugInfo) {\n    this.version++;\n    globalVersion++;\n    this.notify(debugInfo);\n  }\n  notify(debugInfo) {\n    startBatch();\n    try {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        for (let head = this.subsHead; head; head = head.nextSub) {\n          if (head.sub.onTrigger && !(head.sub.flags & 8)) {\n            head.sub.onTrigger(\n              extend(\n                {\n                  effect: head.sub\n                },\n                debugInfo\n              )\n            );\n          }\n        }\n      }\n      for (let link = this.subs; link; link = link.prevSub) {\n        if (link.sub.notify()) {\n          ;\n          link.sub.dep.notify();\n        }\n      }\n    } finally {\n      endBatch();\n    }\n  }\n}\nfunction addSub(link) {\n  const computed = link.dep.computed;\n  if (computed && !link.dep.subs) {\n    computed.flags |= 4 | 16;\n    for (let l = computed.deps; l; l = l.nextDep) {\n      addSub(l);\n    }\n  }\n  const currentTail = link.dep.subs;\n  if (currentTail !== link) {\n    link.prevSub = currentTail;\n    if (currentTail) currentTail.nextSub = link;\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") && link.dep.subsHead === void 0) {\n    link.dep.subsHead = link;\n  }\n  link.dep.subs = link;\n}\nconst targetMap = /* @__PURE__ */ new WeakMap();\nconst ITERATE_KEY = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? \"Object iterate\" : \"\"\n);\nconst MAP_KEY_ITERATE_KEY = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? \"Map keys iterate\" : \"\"\n);\nconst ARRAY_ITERATE_KEY = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? \"Array iterate\" : \"\"\n);\nfunction track(target, type, key) {\n  if (shouldTrack && activeSub) {\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n      depsMap.set(key, dep = new Dep());\n      dep.target = target;\n      dep.map = depsMap;\n      dep.key = key;\n    }\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      dep.track({\n        target,\n        type,\n        key\n      });\n    } else {\n      dep.track();\n    }\n  }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) {\n    globalVersion++;\n    return;\n  }\n  const run = (dep) => {\n    if (dep) {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        dep.trigger({\n          target,\n          type,\n          key,\n          newValue,\n          oldValue,\n          oldTarget\n        });\n      } else {\n        dep.trigger();\n      }\n    }\n  };\n  startBatch();\n  if (type === \"clear\") {\n    depsMap.forEach(run);\n  } else {\n    const targetIsArray = isArray(target);\n    const isArrayIndex = targetIsArray && isIntegerKey(key);\n    if (targetIsArray && key === \"length\") {\n      const newLength = Number(newValue);\n      depsMap.forEach((dep, key2) => {\n        if (key2 === \"length\" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {\n          run(dep);\n        }\n      });\n    } else {\n      if (key !== void 0) {\n        run(depsMap.get(key));\n      }\n      if (isArrayIndex) {\n        run(depsMap.get(ARRAY_ITERATE_KEY));\n      }\n      switch (type) {\n        case \"add\":\n          if (!targetIsArray) {\n            run(depsMap.get(ITERATE_KEY));\n            if (isMap(target)) {\n              run(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          } else if (isArrayIndex) {\n            run(depsMap.get(\"length\"));\n          }\n          break;\n        case \"delete\":\n          if (!targetIsArray) {\n            run(depsMap.get(ITERATE_KEY));\n            if (isMap(target)) {\n              run(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          }\n          break;\n        case \"set\":\n          if (isMap(target)) {\n            run(depsMap.get(ITERATE_KEY));\n          }\n          break;\n      }\n    }\n  }\n  endBatch();\n}\nfunction getDepFromReactive(object, key) {\n  var _a;\n  return (_a = targetMap.get(object)) == null ? void 0 : _a.get(key);\n}\n\nfunction reactiveReadArray(array) {\n  const raw = toRaw(array);\n  if (raw === array) return raw;\n  track(raw, \"iterate\", ARRAY_ITERATE_KEY);\n  return isShallow(array) ? raw : raw.map(toReactive);\n}\nfunction shallowReadArray(arr) {\n  track(arr = toRaw(arr), \"iterate\", ARRAY_ITERATE_KEY);\n  return arr;\n}\nconst arrayInstrumentations = {\n  __proto__: null,\n  [Symbol.iterator]() {\n    return iterator(this, Symbol.iterator, toReactive);\n  },\n  concat(...args) {\n    return reactiveReadArray(this).concat(\n      ...args.map((x) => isArray(x) ? reactiveReadArray(x) : x)\n    );\n  },\n  entries() {\n    return iterator(this, \"entries\", (value) => {\n      value[1] = toReactive(value[1]);\n      return value;\n    });\n  },\n  every(fn, thisArg) {\n    return apply(this, \"every\", fn, thisArg, void 0, arguments);\n  },\n  filter(fn, thisArg) {\n    return apply(this, \"filter\", fn, thisArg, (v) => v.map(toReactive), arguments);\n  },\n  find(fn, thisArg) {\n    return apply(this, \"find\", fn, thisArg, toReactive, arguments);\n  },\n  findIndex(fn, thisArg) {\n    return apply(this, \"findIndex\", fn, thisArg, void 0, arguments);\n  },\n  findLast(fn, thisArg) {\n    return apply(this, \"findLast\", fn, thisArg, toReactive, arguments);\n  },\n  findLastIndex(fn, thisArg) {\n    return apply(this, \"findLastIndex\", fn, thisArg, void 0, arguments);\n  },\n  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement\n  forEach(fn, thisArg) {\n    return apply(this, \"forEach\", fn, thisArg, void 0, arguments);\n  },\n  includes(...args) {\n    return searchProxy(this, \"includes\", args);\n  },\n  indexOf(...args) {\n    return searchProxy(this, \"indexOf\", args);\n  },\n  join(separator) {\n    return reactiveReadArray(this).join(separator);\n  },\n  // keys() iterator only reads `length`, no optimisation required\n  lastIndexOf(...args) {\n    return searchProxy(this, \"lastIndexOf\", args);\n  },\n  map(fn, thisArg) {\n    return apply(this, \"map\", fn, thisArg, void 0, arguments);\n  },\n  pop() {\n    return noTracking(this, \"pop\");\n  },\n  push(...args) {\n    return noTracking(this, \"push\", args);\n  },\n  reduce(fn, ...args) {\n    return reduce(this, \"reduce\", fn, args);\n  },\n  reduceRight(fn, ...args) {\n    return reduce(this, \"reduceRight\", fn, args);\n  },\n  shift() {\n    return noTracking(this, \"shift\");\n  },\n  // slice could use ARRAY_ITERATE but also seems to beg for range tracking\n  some(fn, thisArg) {\n    return apply(this, \"some\", fn, thisArg, void 0, arguments);\n  },\n  splice(...args) {\n    return noTracking(this, \"splice\", args);\n  },\n  toReversed() {\n    return reactiveReadArray(this).toReversed();\n  },\n  toSorted(comparer) {\n    return reactiveReadArray(this).toSorted(comparer);\n  },\n  toSpliced(...args) {\n    return reactiveReadArray(this).toSpliced(...args);\n  },\n  unshift(...args) {\n    return noTracking(this, \"unshift\", args);\n  },\n  values() {\n    return iterator(this, \"values\", toReactive);\n  }\n};\nfunction iterator(self, method, wrapValue) {\n  const arr = shallowReadArray(self);\n  const iter = arr[method]();\n  if (arr !== self && !isShallow(self)) {\n    iter._next = iter.next;\n    iter.next = () => {\n      const result = iter._next();\n      if (result.value) {\n        result.value = wrapValue(result.value);\n      }\n      return result;\n    };\n  }\n  return iter;\n}\nconst arrayProto = Array.prototype;\nfunction apply(self, method, fn, thisArg, wrappedRetFn, args) {\n  const arr = shallowReadArray(self);\n  const needsWrap = arr !== self && !isShallow(self);\n  const methodFn = arr[method];\n  if (methodFn !== arrayProto[method]) {\n    const result2 = methodFn.apply(self, args);\n    return needsWrap ? toReactive(result2) : result2;\n  }\n  let wrappedFn = fn;\n  if (arr !== self) {\n    if (needsWrap) {\n      wrappedFn = function(item, index) {\n        return fn.call(this, toReactive(item), index, self);\n      };\n    } else if (fn.length > 2) {\n      wrappedFn = function(item, index) {\n        return fn.call(this, item, index, self);\n      };\n    }\n  }\n  const result = methodFn.call(arr, wrappedFn, thisArg);\n  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;\n}\nfunction reduce(self, method, fn, args) {\n  const arr = shallowReadArray(self);\n  let wrappedFn = fn;\n  if (arr !== self) {\n    if (!isShallow(self)) {\n      wrappedFn = function(acc, item, index) {\n        return fn.call(this, acc, toReactive(item), index, self);\n      };\n    } else if (fn.length > 3) {\n      wrappedFn = function(acc, item, index) {\n        return fn.call(this, acc, item, index, self);\n      };\n    }\n  }\n  return arr[method](wrappedFn, ...args);\n}\nfunction searchProxy(self, method, args) {\n  const arr = toRaw(self);\n  track(arr, \"iterate\", ARRAY_ITERATE_KEY);\n  const res = arr[method](...args);\n  if ((res === -1 || res === false) && isProxy(args[0])) {\n    args[0] = toRaw(args[0]);\n    return arr[method](...args);\n  }\n  return res;\n}\nfunction noTracking(self, method, args = []) {\n  pauseTracking();\n  startBatch();\n  const res = toRaw(self)[method].apply(self, args);\n  endBatch();\n  resetTracking();\n  return res;\n}\n\nconst isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set(\n  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== \"arguments\" && key !== \"caller\").map((key) => Symbol[key]).filter(isSymbol)\n);\nfunction hasOwnProperty(key) {\n  if (!isSymbol(key)) key = String(key);\n  const obj = toRaw(this);\n  track(obj, \"has\", key);\n  return obj.hasOwnProperty(key);\n}\nclass BaseReactiveHandler {\n  constructor(_isReadonly = false, _isShallow = false) {\n    this._isReadonly = _isReadonly;\n    this._isShallow = _isShallow;\n  }\n  get(target, key, receiver) {\n    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_isShallow\") {\n      return isShallow2;\n    } else if (key === \"__v_raw\") {\n      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype\n      // this means the receiver is a user proxy of the reactive proxy\n      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {\n        return target;\n      }\n      return;\n    }\n    const targetIsArray = isArray(target);\n    if (!isReadonly2) {\n      let fn;\n      if (targetIsArray && (fn = arrayInstrumentations[key])) {\n        return fn;\n      }\n      if (key === \"hasOwnProperty\") {\n        return hasOwnProperty;\n      }\n    }\n    const res = Reflect.get(\n      target,\n      key,\n      // if this is a proxy wrapping a ref, return methods using the raw ref\n      // as receiver so that we don't have to call `toRaw` on the ref in all\n      // its class methods\n      isRef(target) ? target : receiver\n    );\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n    if (!isReadonly2) {\n      track(target, \"get\", key);\n    }\n    if (isShallow2) {\n      return res;\n    }\n    if (isRef(res)) {\n      return targetIsArray && isIntegerKey(key) ? res : res.value;\n    }\n    if (isObject(res)) {\n      return isReadonly2 ? readonly(res) : reactive(res);\n    }\n    return res;\n  }\n}\nclass MutableReactiveHandler extends BaseReactiveHandler {\n  constructor(isShallow2 = false) {\n    super(false, isShallow2);\n  }\n  set(target, key, value, receiver) {\n    let oldValue = target[key];\n    if (!this._isShallow) {\n      const isOldValueReadonly = isReadonly(oldValue);\n      if (!isShallow(value) && !isReadonly(value)) {\n        oldValue = toRaw(oldValue);\n        value = toRaw(value);\n      }\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        if (isOldValueReadonly) {\n          return false;\n        } else {\n          oldValue.value = value;\n          return true;\n        }\n      }\n    }\n    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\n    const result = Reflect.set(\n      target,\n      key,\n      value,\n      isRef(target) ? target : receiver\n    );\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\", key, value);\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\", key, value, oldValue);\n      }\n    }\n    return result;\n  }\n  deleteProperty(target, key) {\n    const hadKey = hasOwn(target, key);\n    const oldValue = target[key];\n    const result = Reflect.deleteProperty(target, key);\n    if (result && hadKey) {\n      trigger(target, \"delete\", key, void 0, oldValue);\n    }\n    return result;\n  }\n  has(target, key) {\n    const result = Reflect.has(target, key);\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\n      track(target, \"has\", key);\n    }\n    return result;\n  }\n  ownKeys(target) {\n    track(\n      target,\n      \"iterate\",\n      isArray(target) ? \"length\" : ITERATE_KEY\n    );\n    return Reflect.ownKeys(target);\n  }\n}\nclass ReadonlyReactiveHandler extends BaseReactiveHandler {\n  constructor(isShallow2 = false) {\n    super(true, isShallow2);\n  }\n  set(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  }\n  deleteProperty(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `Delete operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  }\n}\nconst mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();\nconst readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();\nconst shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);\nconst shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);\n\nconst toShallow = (value) => value;\nconst getProto = (v) => Reflect.getPrototypeOf(v);\nfunction get(target, key, isReadonly2 = false, isShallow2 = false) {\n  target = target[\"__v_raw\"];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n  if (!isReadonly2) {\n    if (hasChanged(key, rawKey)) {\n      track(rawTarget, \"get\", key);\n    }\n    track(rawTarget, \"get\", rawKey);\n  }\n  const { has: has2 } = getProto(rawTarget);\n  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;\n  if (has2.call(rawTarget, key)) {\n    return wrap(target.get(key));\n  } else if (has2.call(rawTarget, rawKey)) {\n    return wrap(target.get(rawKey));\n  } else if (target !== rawTarget) {\n    target.get(key);\n  }\n}\nfunction has(key, isReadonly2 = false) {\n  const target = this[\"__v_raw\"];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n  if (!isReadonly2) {\n    if (hasChanged(key, rawKey)) {\n      track(rawTarget, \"has\", key);\n    }\n    track(rawTarget, \"has\", rawKey);\n  }\n  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n}\nfunction size(target, isReadonly2 = false) {\n  target = target[\"__v_raw\"];\n  !isReadonly2 && track(toRaw(target), \"iterate\", ITERATE_KEY);\n  return Reflect.get(target, \"size\", target);\n}\nfunction add(value, _isShallow = false) {\n  if (!_isShallow && !isShallow(value) && !isReadonly(value)) {\n    value = toRaw(value);\n  }\n  const target = toRaw(this);\n  const proto = getProto(target);\n  const hadKey = proto.has.call(target, value);\n  if (!hadKey) {\n    target.add(value);\n    trigger(target, \"add\", value, value);\n  }\n  return this;\n}\nfunction set(key, value, _isShallow = false) {\n  if (!_isShallow && !isShallow(value) && !isReadonly(value)) {\n    value = toRaw(value);\n  }\n  const target = toRaw(this);\n  const { has: has2, get: get2 } = getProto(target);\n  let hadKey = has2.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has2.call(target, key);\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    checkIdentityKeys(target, has2, key);\n  }\n  const oldValue = get2.call(target, key);\n  target.set(key, value);\n  if (!hadKey) {\n    trigger(target, \"add\", key, value);\n  } else if (hasChanged(value, oldValue)) {\n    trigger(target, \"set\", key, value, oldValue);\n  }\n  return this;\n}\nfunction deleteEntry(key) {\n  const target = toRaw(this);\n  const { has: has2, get: get2 } = getProto(target);\n  let hadKey = has2.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has2.call(target, key);\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    checkIdentityKeys(target, has2, key);\n  }\n  const oldValue = get2 ? get2.call(target, key) : void 0;\n  const result = target.delete(key);\n  if (hadKey) {\n    trigger(target, \"delete\", key, void 0, oldValue);\n  }\n  return result;\n}\nfunction clear() {\n  const target = toRaw(this);\n  const hadItems = target.size !== 0;\n  const oldTarget = !!(process.env.NODE_ENV !== \"production\") ? isMap(target) ? new Map(target) : new Set(target) : void 0;\n  const result = target.clear();\n  if (hadItems) {\n    trigger(target, \"clear\", void 0, void 0, oldTarget);\n  }\n  return result;\n}\nfunction createForEach(isReadonly2, isShallow2) {\n  return function forEach(callback, thisArg) {\n    const observed = this;\n    const target = observed[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;\n    !isReadonly2 && track(rawTarget, \"iterate\", ITERATE_KEY);\n    return target.forEach((value, key) => {\n      return callback.call(thisArg, wrap(value), wrap(key), observed);\n    });\n  };\n}\nfunction createIterableMethod(method, isReadonly2, isShallow2) {\n  return function(...args) {\n    const target = this[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const targetIsMap = isMap(rawTarget);\n    const isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === \"keys\" && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;\n    !isReadonly2 && track(\n      rawTarget,\n      \"iterate\",\n      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY\n    );\n    return {\n      // iterator protocol\n      next() {\n        const { value, done } = innerIterator.next();\n        return done ? { value, done } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n  };\n}\nfunction createReadonlyMethod(type) {\n  return function(...args) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n      warn(\n        `${capitalize(type)} operation ${key}failed: target is readonly.`,\n        toRaw(this)\n      );\n    }\n    return type === \"delete\" ? false : type === \"clear\" ? void 0 : this;\n  };\n}\nfunction createInstrumentations() {\n  const mutableInstrumentations2 = {\n    get(key) {\n      return get(this, key);\n    },\n    get size() {\n      return size(this);\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, false)\n  };\n  const shallowInstrumentations2 = {\n    get(key) {\n      return get(this, key, false, true);\n    },\n    get size() {\n      return size(this);\n    },\n    has,\n    add(value) {\n      return add.call(this, value, true);\n    },\n    set(key, value) {\n      return set.call(this, key, value, true);\n    },\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, true)\n  };\n  const readonlyInstrumentations2 = {\n    get(key) {\n      return get(this, key, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\"),\n    set: createReadonlyMethod(\"set\"),\n    delete: createReadonlyMethod(\"delete\"),\n    clear: createReadonlyMethod(\"clear\"),\n    forEach: createForEach(true, false)\n  };\n  const shallowReadonlyInstrumentations2 = {\n    get(key) {\n      return get(this, key, true, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\"),\n    set: createReadonlyMethod(\"set\"),\n    delete: createReadonlyMethod(\"delete\"),\n    clear: createReadonlyMethod(\"clear\"),\n    forEach: createForEach(true, true)\n  };\n  const iteratorMethods = [\n    \"keys\",\n    \"values\",\n    \"entries\",\n    Symbol.iterator\n  ];\n  iteratorMethods.forEach((method) => {\n    mutableInstrumentations2[method] = createIterableMethod(method, false, false);\n    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);\n    shallowInstrumentations2[method] = createIterableMethod(method, false, true);\n    shallowReadonlyInstrumentations2[method] = createIterableMethod(\n      method,\n      true,\n      true\n    );\n  });\n  return [\n    mutableInstrumentations2,\n    readonlyInstrumentations2,\n    shallowInstrumentations2,\n    shallowReadonlyInstrumentations2\n  ];\n}\nconst [\n  mutableInstrumentations,\n  readonlyInstrumentations,\n  shallowInstrumentations,\n  shallowReadonlyInstrumentations\n] = /* @__PURE__ */ createInstrumentations();\nfunction createInstrumentationGetter(isReadonly2, shallow) {\n  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;\n  return (target, key, receiver) => {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_raw\") {\n      return target;\n    }\n    return Reflect.get(\n      hasOwn(instrumentations, key) && key in target ? instrumentations : target,\n      key,\n      receiver\n    );\n  };\n}\nconst mutableCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, true)\n};\nfunction checkIdentityKeys(target, has2, key) {\n  const rawKey = toRaw(key);\n  if (rawKey !== key && has2.call(target, rawKey)) {\n    const type = toRawType(target);\n    warn(\n      `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`\n    );\n  }\n}\n\nconst reactiveMap = /* @__PURE__ */ new WeakMap();\nconst shallowReactiveMap = /* @__PURE__ */ new WeakMap();\nconst readonlyMap = /* @__PURE__ */ new WeakMap();\nconst shallowReadonlyMap = /* @__PURE__ */ new WeakMap();\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case \"Object\":\n    case \"Array\":\n      return 1 /* COMMON */;\n    case \"Map\":\n    case \"Set\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n      return 2 /* COLLECTION */;\n    default:\n      return 0 /* INVALID */;\n  }\n}\nfunction getTargetType(value) {\n  return value[\"__v_skip\"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap(toRawType(value));\n}\nfunction reactive(target) {\n  if (isReadonly(target)) {\n    return target;\n  }\n  return createReactiveObject(\n    target,\n    false,\n    mutableHandlers,\n    mutableCollectionHandlers,\n    reactiveMap\n  );\n}\nfunction shallowReactive(target) {\n  return createReactiveObject(\n    target,\n    false,\n    shallowReactiveHandlers,\n    shallowCollectionHandlers,\n    shallowReactiveMap\n  );\n}\nfunction readonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    readonlyHandlers,\n    readonlyCollectionHandlers,\n    readonlyMap\n  );\n}\nfunction shallowReadonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    shallowReadonlyHandlers,\n    shallowReadonlyCollectionHandlers,\n    shallowReadonlyMap\n  );\n}\nfunction createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {\n  if (!isObject(target)) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `value cannot be made ${isReadonly2 ? \"readonly\" : \"reactive\"}: ${String(\n          target\n        )}`\n      );\n    }\n    return target;\n  }\n  if (target[\"__v_raw\"] && !(isReadonly2 && target[\"__v_isReactive\"])) {\n    return target;\n  }\n  const existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n  const targetType = getTargetType(target);\n  if (targetType === 0 /* INVALID */) {\n    return target;\n  }\n  const proxy = new Proxy(\n    target,\n    targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers\n  );\n  proxyMap.set(target, proxy);\n  return proxy;\n}\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\"]);\n  }\n  return !!(value && value[\"__v_isReactive\"]);\n}\nfunction isReadonly(value) {\n  return !!(value && value[\"__v_isReadonly\"]);\n}\nfunction isShallow(value) {\n  return !!(value && value[\"__v_isShallow\"]);\n}\nfunction isProxy(value) {\n  return value ? !!value[\"__v_raw\"] : false;\n}\nfunction toRaw(observed) {\n  const raw = observed && observed[\"__v_raw\"];\n  return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n  if (!hasOwn(value, \"__v_skip\") && Object.isExtensible(value)) {\n    def(value, \"__v_skip\", true);\n  }\n  return value;\n}\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\n\nfunction isRef(r) {\n  return r ? r[\"__v_isRef\"] === true : false;\n}\nfunction ref(value) {\n  return createRef(value, false);\n}\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n  return new RefImpl(rawValue, shallow);\n}\nclass RefImpl {\n  constructor(value, isShallow2) {\n    this.dep = new Dep();\n    this[\"__v_isRef\"] = true;\n    this[\"__v_isShallow\"] = false;\n    this._rawValue = isShallow2 ? value : toRaw(value);\n    this._value = isShallow2 ? value : toReactive(value);\n    this[\"__v_isShallow\"] = isShallow2;\n  }\n  get value() {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      this.dep.track({\n        target: this,\n        type: \"get\",\n        key: \"value\"\n      });\n    } else {\n      this.dep.track();\n    }\n    return this._value;\n  }\n  set value(newValue) {\n    const oldValue = this._rawValue;\n    const useDirectValue = this[\"__v_isShallow\"] || isShallow(newValue) || isReadonly(newValue);\n    newValue = useDirectValue ? newValue : toRaw(newValue);\n    if (hasChanged(newValue, oldValue)) {\n      this._rawValue = newValue;\n      this._value = useDirectValue ? newValue : toReactive(newValue);\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        this.dep.trigger({\n          target: this,\n          type: \"set\",\n          key: \"value\",\n          newValue,\n          oldValue\n        });\n      } else {\n        this.dep.trigger();\n      }\n    }\n  }\n}\nfunction triggerRef(ref2) {\n  if (ref2.dep) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      ref2.dep.trigger({\n        target: ref2,\n        type: \"set\",\n        key: \"value\",\n        newValue: ref2._value\n      });\n    } else {\n      ref2.dep.trigger();\n    }\n  }\n}\nfunction unref(ref2) {\n  return isRef(ref2) ? ref2.value : ref2;\n}\nfunction toValue(source) {\n  return isFunction(source) ? source() : unref(source);\n}\nconst shallowUnwrapHandlers = {\n  get: (target, key, receiver) => key === \"__v_raw\" ? target : unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key];\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nclass CustomRefImpl {\n  constructor(factory) {\n    this[\"__v_isRef\"] = true;\n    this._value = void 0;\n    const dep = this.dep = new Dep();\n    const { get, set } = factory(dep.track.bind(dep), dep.trigger.bind(dep));\n    this._get = get;\n    this._set = set;\n  }\n  get value() {\n    return this._value = this._get();\n  }\n  set value(newVal) {\n    this._set(newVal);\n  }\n}\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\nfunction toRefs(object) {\n  if (!!(process.env.NODE_ENV !== \"production\") && !isProxy(object)) {\n    warn(`toRefs() expects a reactive object but received a plain one.`);\n  }\n  const ret = isArray(object) ? new Array(object.length) : {};\n  for (const key in object) {\n    ret[key] = propertyToRef(object, key);\n  }\n  return ret;\n}\nclass ObjectRefImpl {\n  constructor(_object, _key, _defaultValue) {\n    this._object = _object;\n    this._key = _key;\n    this._defaultValue = _defaultValue;\n    this[\"__v_isRef\"] = true;\n    this._value = void 0;\n  }\n  get value() {\n    const val = this._object[this._key];\n    return this._value = val === void 0 ? this._defaultValue : val;\n  }\n  set value(newVal) {\n    this._object[this._key] = newVal;\n  }\n  get dep() {\n    return getDepFromReactive(toRaw(this._object), this._key);\n  }\n}\nclass GetterRefImpl {\n  constructor(_getter) {\n    this._getter = _getter;\n    this[\"__v_isRef\"] = true;\n    this[\"__v_isReadonly\"] = true;\n    this._value = void 0;\n  }\n  get value() {\n    return this._value = this._getter();\n  }\n}\nfunction toRef(source, key, defaultValue) {\n  if (isRef(source)) {\n    return source;\n  } else if (isFunction(source)) {\n    return new GetterRefImpl(source);\n  } else if (isObject(source) && arguments.length > 1) {\n    return propertyToRef(source, key, defaultValue);\n  } else {\n    return ref(source);\n  }\n}\nfunction propertyToRef(source, key, defaultValue) {\n  const val = source[key];\n  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);\n}\n\nclass ComputedRefImpl {\n  constructor(fn, setter, isSSR) {\n    this.fn = fn;\n    this.setter = setter;\n    /**\n     * @internal\n     */\n    this._value = void 0;\n    /**\n     * @internal\n     */\n    this.dep = new Dep(this);\n    /**\n     * @internal\n     */\n    this.__v_isRef = true;\n    // TODO isolatedDeclarations \"__v_isReadonly\"\n    // A computed is also a subscriber that tracks other deps\n    /**\n     * @internal\n     */\n    this.deps = void 0;\n    /**\n     * @internal\n     */\n    this.depsTail = void 0;\n    /**\n     * @internal\n     */\n    this.flags = 16;\n    /**\n     * @internal\n     */\n    this.globalVersion = globalVersion - 1;\n    // for backwards compat\n    this.effect = this;\n    this[\"__v_isReadonly\"] = !setter;\n    this.isSSR = isSSR;\n  }\n  /**\n   * @internal\n   */\n  notify() {\n    this.flags |= 16;\n    if (!(this.flags & 8) && // avoid infinite self recursion\n    activeSub !== this) {\n      batch(this);\n      return true;\n    } else if (!!(process.env.NODE_ENV !== \"production\")) ;\n  }\n  get value() {\n    const link = !!(process.env.NODE_ENV !== \"production\") ? this.dep.track({\n      target: this,\n      type: \"get\",\n      key: \"value\"\n    }) : this.dep.track();\n    refreshComputed(this);\n    if (link) {\n      link.version = this.dep.version;\n    }\n    return this._value;\n  }\n  set value(newValue) {\n    if (this.setter) {\n      this.setter(newValue);\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\"Write operation failed: computed value is readonly\");\n    }\n  }\n}\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n  let getter;\n  let setter;\n  if (isFunction(getterOrOptions)) {\n    getter = getterOrOptions;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n  const cRef = new ComputedRefImpl(getter, setter, isSSR);\n  if (!!(process.env.NODE_ENV !== \"production\") && debugOptions && !isSSR) {\n    cRef.onTrack = debugOptions.onTrack;\n    cRef.onTrigger = debugOptions.onTrigger;\n  }\n  return cRef;\n}\n\nconst TrackOpTypes = {\n  \"GET\": \"get\",\n  \"HAS\": \"has\",\n  \"ITERATE\": \"iterate\"\n};\nconst TriggerOpTypes = {\n  \"SET\": \"set\",\n  \"ADD\": \"add\",\n  \"DELETE\": \"delete\",\n  \"CLEAR\": \"clear\"\n};\nconst ReactiveFlags = {\n  \"SKIP\": \"__v_skip\",\n  \"IS_REACTIVE\": \"__v_isReactive\",\n  \"IS_READONLY\": \"__v_isReadonly\",\n  \"IS_SHALLOW\": \"__v_isShallow\",\n  \"RAW\": \"__v_raw\",\n  \"IS_REF\": \"__v_isRef\"\n};\n\nconst WatchErrorCodes = {\n  \"WATCH_GETTER\": 2,\n  \"2\": \"WATCH_GETTER\",\n  \"WATCH_CALLBACK\": 3,\n  \"3\": \"WATCH_CALLBACK\",\n  \"WATCH_CLEANUP\": 4,\n  \"4\": \"WATCH_CLEANUP\"\n};\nconst INITIAL_WATCHER_VALUE = {};\nconst cleanupMap = /* @__PURE__ */ new WeakMap();\nlet activeWatcher = void 0;\nfunction getCurrentWatcher() {\n  return activeWatcher;\n}\nfunction onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {\n  if (owner) {\n    let cleanups = cleanupMap.get(owner);\n    if (!cleanups) cleanupMap.set(owner, cleanups = []);\n    cleanups.push(cleanupFn);\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(\n      `onWatcherCleanup() was called when there was no active watcher to associate with.`\n    );\n  }\n}\nfunction watch(source, cb, options = EMPTY_OBJ) {\n  const { immediate, deep, once, scheduler, augmentJob, call } = options;\n  const warnInvalidSource = (s) => {\n    (options.onWarn || warn)(\n      `Invalid watch source: `,\n      s,\n      `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`\n    );\n  };\n  const reactiveGetter = (source2) => {\n    if (deep) return source2;\n    if (isShallow(source2) || deep === false || deep === 0)\n      return traverse(source2, 1);\n    return traverse(source2);\n  };\n  let effect;\n  let getter;\n  let cleanup;\n  let boundCleanup;\n  let forceTrigger = false;\n  let isMultiSource = false;\n  if (isRef(source)) {\n    getter = () => source.value;\n    forceTrigger = isShallow(source);\n  } else if (isReactive(source)) {\n    getter = () => reactiveGetter(source);\n    forceTrigger = true;\n  } else if (isArray(source)) {\n    isMultiSource = true;\n    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));\n    getter = () => source.map((s) => {\n      if (isRef(s)) {\n        return s.value;\n      } else if (isReactive(s)) {\n        return reactiveGetter(s);\n      } else if (isFunction(s)) {\n        return call ? call(s, 2) : s();\n      } else {\n        !!(process.env.NODE_ENV !== \"production\") && warnInvalidSource(s);\n      }\n    });\n  } else if (isFunction(source)) {\n    if (cb) {\n      getter = call ? () => call(source, 2) : source;\n    } else {\n      getter = () => {\n        if (cleanup) {\n          pauseTracking();\n          try {\n            cleanup();\n          } finally {\n            resetTracking();\n          }\n        }\n        const currentEffect = activeWatcher;\n        activeWatcher = effect;\n        try {\n          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);\n        } finally {\n          activeWatcher = currentEffect;\n        }\n      };\n    }\n  } else {\n    getter = NOOP;\n    !!(process.env.NODE_ENV !== \"production\") && warnInvalidSource(source);\n  }\n  if (cb && deep) {\n    const baseGetter = getter;\n    const depth = deep === true ? Infinity : deep;\n    getter = () => traverse(baseGetter(), depth);\n  }\n  const scope = getCurrentScope();\n  const watchHandle = () => {\n    effect.stop();\n    if (scope) {\n      remove(scope.effects, effect);\n    }\n  };\n  if (once && cb) {\n    const _cb = cb;\n    cb = (...args) => {\n      _cb(...args);\n      watchHandle();\n    };\n  }\n  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;\n  const job = (immediateFirstRun) => {\n    if (!(effect.flags & 1) || !effect.dirty && !immediateFirstRun) {\n      return;\n    }\n    if (cb) {\n      const newValue = effect.run();\n      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {\n        if (cleanup) {\n          cleanup();\n        }\n        const currentWatcher = activeWatcher;\n        activeWatcher = effect;\n        try {\n          const args = [\n            newValue,\n            // pass undefined as the old value when it's changed for the first time\n            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,\n            boundCleanup\n          ];\n          call ? call(cb, 3, args) : (\n            // @ts-expect-error\n            cb(...args)\n          );\n          oldValue = newValue;\n        } finally {\n          activeWatcher = currentWatcher;\n        }\n      }\n    } else {\n      effect.run();\n    }\n  };\n  if (augmentJob) {\n    augmentJob(job);\n  }\n  effect = new ReactiveEffect(getter);\n  effect.scheduler = scheduler ? () => scheduler(job, false) : job;\n  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect);\n  cleanup = effect.onStop = () => {\n    const cleanups = cleanupMap.get(effect);\n    if (cleanups) {\n      if (call) {\n        call(cleanups, 4);\n      } else {\n        for (const cleanup2 of cleanups) cleanup2();\n      }\n      cleanupMap.delete(effect);\n    }\n  };\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    effect.onTrack = options.onTrack;\n    effect.onTrigger = options.onTrigger;\n  }\n  if (cb) {\n    if (immediate) {\n      job(true);\n    } else {\n      oldValue = effect.run();\n    }\n  } else if (scheduler) {\n    scheduler(job.bind(null, true), true);\n  } else {\n    effect.run();\n  }\n  watchHandle.pause = effect.pause.bind(effect);\n  watchHandle.resume = effect.resume.bind(effect);\n  watchHandle.stop = watchHandle;\n  return watchHandle;\n}\nfunction traverse(value, depth = Infinity, seen) {\n  if (depth <= 0 || !isObject(value) || value[\"__v_skip\"]) {\n    return value;\n  }\n  seen = seen || /* @__PURE__ */ new Set();\n  if (seen.has(value)) {\n    return value;\n  }\n  seen.add(value);\n  depth--;\n  if (isRef(value)) {\n    traverse(value.value, depth, seen);\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      traverse(value[i], depth, seen);\n    }\n  } else if (isSet(value) || isMap(value)) {\n    value.forEach((v) => {\n      traverse(v, depth, seen);\n    });\n  } else if (isPlainObject(value)) {\n    for (const key in value) {\n      traverse(value[key], depth, seen);\n    }\n    for (const key of Object.getOwnPropertySymbols(value)) {\n      if (Object.prototype.propertyIsEnumerable.call(value, key)) {\n        traverse(value[key], depth, seen);\n      }\n    }\n  }\n  return value;\n}\n\nexport { ARRAY_ITERATE_KEY, EffectFlags, EffectScope, ITERATE_KEY, MAP_KEY_ITERATE_KEY, ReactiveEffect, ReactiveFlags, TrackOpTypes, TriggerOpTypes, WatchErrorCodes, computed, customRef, effect, effectScope, enableTracking, getCurrentScope, getCurrentWatcher, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onEffectCleanup, onScopeDispose, onWatcherCleanup, pauseTracking, proxyRefs, reactive, reactiveReadArray, readonly, ref, resetTracking, shallowReactive, shallowReadArray, shallowReadonly, shallowRef, stop, toRaw, toReactive, toReadonly, toRef, toRefs, toValue, track, traverse, trigger, triggerRef, unref, watch };\n","/**\n * Fexios\n * @desc Fetch based HTTP client with similar API to axios for browser and Node.js\n *\n * @license MIT\n * @author dragon-fish <dragon-fish@qq.com>\n */\nclass u {\n  constructor(s = {}) {\n    this.baseConfigs = s, this.hooks = [], this.DEFAULT_CONFIGS = {\n      baseURL: \"\",\n      timeout: 60 * 1e3,\n      credentials: \"same-origin\",\n      headers: {},\n      query: {},\n      responseType: \"json\"\n    }, this.ALL_METHODS = [\n      \"get\",\n      \"post\",\n      \"put\",\n      \"patch\",\n      \"delete\",\n      \"head\",\n      \"options\",\n      \"trace\"\n    ], this.METHODS_WITHOUT_BODY = [\n      \"get\",\n      \"head\",\n      \"options\",\n      \"trace\"\n    ], this.interceptors = {\n      request: this.createInterceptor(\"beforeRequest\"),\n      response: this.createInterceptor(\"afterResponse\")\n    }, this.create = u.create, this.ALL_METHODS.forEach(this.createMethodShortcut.bind(this));\n  }\n  async request(s, t) {\n    var b, y, m, w;\n    let e = t = t || {};\n    e.url = s.toString(), e = await this.emit(\"beforeInit\", e);\n    const o = t.baseURL || this.baseConfigs.baseURL || ((b = globalThis.location) == null ? void 0 : b.href), h = o ? new URL(o, (y = globalThis.location) == null ? void 0 : y.href) : void 0, i = new URL(e.url.toString(), h);\n    if (e.url = i.href, e.baseURL = h ? h.href : i.origin, e.headers = this.mergeHeaders(\n      this.baseConfigs.headers,\n      t.headers\n    ), e.query = this.mergeQuery(\n      this.baseConfigs.query,\n      i.searchParams,\n      t.query\n    ), i.search = new URLSearchParams(e.query).toString(), e.url = i.toString(), this.METHODS_WITHOUT_BODY.includes(\n      (m = e.method) == null ? void 0 : m.toLocaleLowerCase()\n    ) && e.body)\n      throw new c(\n        \"BODY_NOT_ALLOWED\",\n        `Request method \"${e.method}\" does not allow body`\n      );\n    e = await this.emit(\"beforeRequest\", e);\n    let r;\n    typeof e.body < \"u\" && e.body !== null && (e.body instanceof Blob || e.body instanceof FormData || e.body instanceof URLSearchParams ? r = e.body : typeof e.body == \"object\" ? (r = JSON.stringify(e.body), e.headers[\"content-type\"] = \"application/json; charset=UTF-8\") : r = e.body), !((w = t.headers) != null && w[\"content-type\"]) && r && (r instanceof FormData || r instanceof URLSearchParams ? typeof r == \"string\" && typeof e.body == \"object\" ? e.headers[\"content-type\"] = \"application/json; charset=UTF-8\" : r instanceof Blob && (e.headers[\"content-type\"] = r.type) : delete e.headers[\"content-type\"]), e.body = r, e = await this.emit(\"afterBodyTransformed\", e);\n    const n = e.abortController || globalThis.AbortController ? new AbortController() : void 0, f = new Request(e.url, {\n      method: e.method || \"GET\",\n      credentials: e.credentials,\n      headers: e.headers,\n      body: e.body,\n      signal: n == null ? void 0 : n.signal\n    });\n    e.rawRequest = f, e = await this.emit(\"beforeActualFetch\", e);\n    const d = e.timeout || this.baseConfigs.timeout || 60 * 1e3, p = setTimeout(() => {\n      if (n == null || n.abort(), !n)\n        throw new c(\n          \"TIMEOUT\",\n          `Request timed out after ${d}ms`,\n          e\n        );\n    }, d), l = await fetch(e.rawRequest).catch((g) => {\n      throw new c(\"NETWORK_ERROR\", g.message, e);\n    }).finally(() => {\n      clearTimeout(p);\n    });\n    return e.rawResponse = l, e.response = await O(l, e.responseType), e.data = e.response.data, e.headers = e.response.headers, this.emit(\"afterResponse\", e);\n  }\n  mergeQuery(s, ...t) {\n    const e = new URLSearchParams(s);\n    for (const o of t)\n      new URLSearchParams(o).forEach((i, r) => {\n        e.set(r, i);\n      });\n    return Object.fromEntries(e);\n  }\n  mergeHeaders(s, ...t) {\n    const e = {}, o = new Headers(s);\n    for (const h of t)\n      new Headers(h).forEach((r, n) => {\n        o.set(n, r);\n      });\n    return o.forEach((h, i) => {\n      e[i] = h;\n    }), e;\n  }\n  async emit(s, t) {\n    const e = this.hooks.filter((o) => o.event === s);\n    try {\n      let o = 0;\n      for (const h of e) {\n        const i = `${s}#${h.action.name || o}`, r = Symbol(\"FexiosHookContext\");\n        t.__hook_symbol__ = r;\n        const n = await h.action.bind(this)(t);\n        if (t.__hook_symbol__ !== r)\n          throw new c(\n            \"HOOK_CONTEXT_CHANGED\",\n            `Hook \"${i}\" should not override the original FexiosContext object.`\n          );\n        if (n === !1)\n          throw new c(\n            \"ABORTED_BY_HOOK\",\n            `Request aborted by hook \"${i}\"`,\n            t\n          );\n        if (typeof n == \"object\" && n.__hook_symbol__ === r)\n          t = n;\n        else {\n          const f = globalThis[\"\".concat(\"console\")];\n          try {\n            throw new c(\n              \"UNEXPECTED_HOOK_RETURN\",\n              `Hook \"${i}\" should return the original FexiosContext or return false to abort the request, but got \"${n}\".`\n            );\n          } catch (d) {\n            f.warn(d.stack || d);\n          }\n        }\n        delete t.__hook_symbol__, o++;\n      }\n    } catch (o) {\n      return Promise.reject(o);\n    }\n    return t;\n  }\n  on(s, t, e = !1) {\n    if (typeof t != \"function\")\n      throw new c(\n        \"INVALID_HOOK_CALLBACK\",\n        `Hook \"${t}\" should be a function, but got \"${typeof t}\"`\n      );\n    return this.hooks[e ? \"unshift\" : \"push\"]({\n      event: s,\n      action: t\n    }), this;\n  }\n  createInterceptor(s) {\n    return {\n      handlers: () => this.hooks.filter((t) => t.event === s).map((t) => t.action),\n      use: (t, e = !1) => this.on(s, t, e),\n      clear: () => {\n        this.hooks = this.hooks.filter((t) => t.event !== s);\n      }\n    };\n  }\n  createMethodShortcut(s) {\n    return Object.defineProperty(this, s, {\n      value: (t, e, o) => (this.METHODS_WITHOUT_BODY.includes(\n        s.toLocaleLowerCase()\n      ) ? o = e : (o = o || {}, o.body = e), this.request(t, {\n        ...o,\n        method: s\n      }))\n    }), this;\n  }\n  extends(s) {\n    const t = new u({ ...this.baseConfigs, ...s });\n    return t.hooks = [...this.hooks], t;\n  }\n  static create(s) {\n    return new u(s);\n  }\n}\nclass c extends Error {\n  constructor(s, t, e) {\n    super(t), this.code = s, this.context = e, this.name = \"FexiosError\";\n  }\n}\nclass _ extends c {\n  constructor(s, t) {\n    super(t.statusText, s), this.response = t, this.name = \"FexiosResponseError\";\n  }\n}\nconst E = (a) => !(a instanceof _) && a instanceof c;\nasync function O(a, s = \"json\") {\n  let t;\n  s === \"blob\" && (t = await a.clone().blob().catch(() => {\n  })), t || (t = await a.clone().json().catch(() => a.clone().text()));\n  const e = {\n    rawResponse: a,\n    data: t,\n    ok: a.ok,\n    status: a.status,\n    statusText: a.statusText,\n    headers: a.headers\n  };\n  if (!a.ok)\n    throw new _(\n      `Request failed with status code ${a.status}`,\n      e\n    );\n  return e;\n}\nconst R = T();\nfunction T(a) {\n  return u.create(a);\n}\ntypeof window < \"u\" && (window.fexios = T());\nexport {\n  u as Fexios,\n  c as FexiosError,\n  _ as FexiosResponseError,\n  T as createFexios,\n  O as createFexiosResponse,\n  R as default,\n  E as isFexiosError\n};\n//# sourceMappingURL=index.js.map\n","/**\r\n * MediaWiki Api for Axios\r\n * Provides the API call methods similar to `mw.Api` at non-mw environments\r\n *\r\n * @author Dragon-Fish <dragon-fish@qq.com>\r\n * @license MIT\r\n */\r\n\r\nimport { Ref, ref, computed, ComputedRef } from '@vue/reactivity'\r\nimport {\r\n  Fexios,\r\n  FexiosConfigs,\r\n  FexiosRequestOptions,\r\n  FexiosFinalContext,\r\n} from 'fexios'\r\n\r\nexport class MediaWikiApi {\r\n  baseURL: Ref<string>\r\n  private requestHandlerRef: ComputedRef<Fexios>\r\n  private defaultOptionsRef: Ref<Partial<FexiosConfigs>>\r\n  private defaultParamsRef: Ref<MwApiParams>\r\n  private tokens: Record<string, string>\r\n  cookies: Record<string, string> = {}\r\n\r\n  constructor(baseURL?: string, options?: Partial<FexiosConfigs>) {\r\n    // For MediaWiki browser environment\r\n    if (!baseURL && typeof window === 'object' && (window as any).mediaWiki) {\r\n      const { wgServer, wgScriptPath } =\r\n        (window as any).mediaWiki?.config?.get(['wgServer', 'wgScriptPath']) ||\r\n        {}\r\n      if (typeof wgServer === 'string' && typeof wgScriptPath === 'string') {\r\n        baseURL = `${wgServer}${wgScriptPath}/api.php`\r\n      }\r\n    }\r\n    if (typeof baseURL !== 'string') {\r\n      throw new Error('baseURL is undefined')\r\n    }\r\n    // Init\r\n    this.baseURL = ref(baseURL)\r\n    this.tokens = {}\r\n    this.defaultParamsRef = ref({})\r\n    this.defaultOptionsRef = ref({} as any)\r\n\r\n    // Set default values\r\n    this.defaultParams = {\r\n      action: 'query',\r\n      errorformat: 'plaintext',\r\n      format: 'json',\r\n      formatversion: 2,\r\n    }\r\n    this.defaultOptions = options || {}\r\n\r\n    this.requestHandlerRef = computed(() => {\r\n      const instance = MediaWikiApi.createRequestHandler(this.baseURL.value, {\r\n        ...this.defaultOptions,\r\n        query: this.defaultParams as any,\r\n      })\r\n      // Handle cookies for Node.js\r\n      if (!('document' in globalThis)) {\r\n        instance.interceptors.request.use((ctx) => {\r\n          ctx.headers = (ctx.headers as Record<string, string>) || {}\r\n          ctx.headers['cookie'] = Object.keys(this.cookies)\r\n            .map((name) => `${name}=${this.cookies[name]}`)\r\n            .join(';')\r\n          return ctx\r\n        })\r\n        instance.interceptors.response.use((ctx) => {\r\n          const cookieHeaders = (ctx.rawResponse!.headers as Headers).get(\r\n            'set-cookie'\r\n          )\r\n          const rawCookies = cookieHeaders?.split(',').map((i) => i.trim())\r\n          rawCookies?.forEach((i) => {\r\n            const [name, ...value] = i.split(';')[0].split('=')\r\n            this.cookies[name] = value.join('=')\r\n          })\r\n          return ctx\r\n        })\r\n      }\r\n\r\n      return instance\r\n    })\r\n  }\r\n\r\n  static normalizeParamValue(item: MwApiParams[keyof MwApiParams]) {\r\n    if (Array.isArray(item)) {\r\n      return item.join('|')\r\n    } else if (typeof item === 'boolean') {\r\n      return item ? '1' : undefined\r\n    } else if (typeof item === 'number') {\r\n      return '' + item\r\n    } else {\r\n      return item\r\n    }\r\n  }\r\n  static createRequestHandler(\r\n    baseURL: string,\r\n    options: Partial<FexiosRequestOptions> = {}\r\n  ) {\r\n    const instance = new Fexios(options)\r\n    instance.baseConfigs.baseURL = baseURL\r\n\r\n    // Adjust body\r\n    instance.on('beforeInit', (ctx) => {\r\n      if (ctx.method?.toLowerCase() !== 'post') {\r\n        return ctx\r\n      }\r\n\r\n      if (\r\n        typeof ctx.body === 'object' &&\r\n        ctx.body !== null &&\r\n        !(ctx.body instanceof URLSearchParams) &&\r\n        !(ctx.body instanceof FormData)\r\n      ) {\r\n        const body: any = ctx.body\r\n        Object.keys(body).forEach((key) => {\r\n          const data = MediaWikiApi.normalizeParamValue(body[key])\r\n          if (typeof data === 'undefined' || data === null) {\r\n            delete body[key]\r\n          } else if (data !== body[key]) {\r\n            body[key] = data\r\n          }\r\n        })\r\n        ctx.body = new URLSearchParams(ctx.body as any)\r\n      }\r\n\r\n      if (\r\n        (globalThis.FormData && ctx.body instanceof FormData) ||\r\n        ctx.body instanceof URLSearchParams\r\n      ) {\r\n        const body = ctx.body\r\n        // Adjust params\r\n        body.forEach((value, key) => {\r\n          const data = MediaWikiApi.normalizeParamValue(value)\r\n          if (typeof data === 'undefined' || data === null) {\r\n            body.delete(key)\r\n          } else if (data !== value) {\r\n            body.set(key, data as any)\r\n          }\r\n        })\r\n        // Adjust query\r\n        const searchParams = new URLSearchParams(ctx.query as any)\r\n        !searchParams.has('format') &&\r\n          searchParams.set('format', '' + (body.get('format') || 'json'))\r\n        !searchParams.has('formatversion') &&\r\n          searchParams.set(\r\n            'formatversion',\r\n            '' + (body.get('formatversion') || '2')\r\n          )\r\n        body.has('origin') &&\r\n          searchParams.set('origin', '' + body.get('origin'))\r\n        ctx.query = Object.fromEntries(searchParams)\r\n\r\n        // DONT REMOVE THIS\r\n        // TODO: Remove duplicate parameters. There should be a better solution.\r\n        body.has('action') && (ctx.query.action = '' + body.get('action'))\r\n      }\r\n\r\n      return ctx\r\n    })\r\n\r\n    // Adjust query\r\n    instance.on('beforeInit', (ctx) => {\r\n      ctx.query = ctx.query as Record<string, any>\r\n      for (const key in ctx.query) {\r\n        const data = MediaWikiApi.normalizeParamValue(ctx.query[key])\r\n        if (typeof data === 'undefined' || data === null) {\r\n          delete ctx.query[key]\r\n        } else if (data !== ctx.query[key]) {\r\n          ctx.query[key] = '' + data\r\n        }\r\n      }\r\n      return ctx\r\n    })\r\n\r\n    // Adjust origin param\r\n    instance.on('beforeRequest', (ctx) => {\r\n      const url = new URL(ctx.url!)\r\n      if (url.searchParams.has('origin')) {\r\n        const origin = encodeURIComponent(\r\n          url.searchParams.get('origin') || ''\r\n        ).replace(/\\./g, '%2E')\r\n        ctx.query = {}\r\n        url.searchParams.delete('origin')\r\n        ctx.url = `${url}${url.search ? '&' : '?'}origin=${origin}`\r\n      }\r\n      return ctx\r\n    })\r\n\r\n    return instance\r\n  }\r\n\r\n  /** Syntactic Sugar */\r\n  // request handler\r\n  get request() {\r\n    return this.requestHandlerRef.value\r\n  }\r\n  // userOptions\r\n  get defaultOptions() {\r\n    return this.defaultOptionsRef.value\r\n  }\r\n  set defaultOptions(options: Partial<FexiosConfigs>) {\r\n    this.defaultOptionsRef.value = options\r\n  }\r\n  // defaultParams\r\n  get defaultParams() {\r\n    return this.defaultParamsRef.value\r\n  }\r\n  set defaultParams(params: MwApiParams) {\r\n    this.defaultParamsRef.value = params\r\n  }\r\n\r\n  /** Base methods encapsulation */\r\n  get<T = any>(query: MwApiParams, options?: FexiosRequestOptions) {\r\n    return this.request.get<T>('', {\r\n      query: query as any,\r\n      ...options,\r\n    })\r\n  }\r\n  post<T = any>(\r\n    data: MwApiParams | URLSearchParams | FormData,\r\n    options?: FexiosRequestOptions\r\n  ) {\r\n    return this.request.post<T>('', data, options)\r\n  }\r\n\r\n  async login(\r\n    lgname: string,\r\n    lgpassword: string,\r\n    params?: MwApiParams,\r\n    postOptions?: { retry?: number; noCache?: boolean }\r\n  ): Promise<{\r\n    result: 'Success' | 'NeedToken' | 'WrongToken' | 'Failed'\r\n    token?: string\r\n    reason?: {\r\n      code: string\r\n      text: string\r\n    }\r\n    lguserid: number\r\n    lgusername: string\r\n  }> {\r\n    this.defaultOptions.credentials = 'include'\r\n\r\n    postOptions = postOptions || {}\r\n    postOptions.retry ??= 3\r\n\r\n    if (postOptions.retry < 1) {\r\n      throw new WikiSaikouError(\r\n        WikiSaikouErrorCode.LOGIN_RETRY_LIMIT_EXCEEDED,\r\n        'The limit of the number of times to automatically re-login has been exceeded'\r\n      )\r\n    }\r\n\r\n    // FIXME: This is ugly\r\n    let data: any\r\n    try {\r\n      const res = await this.postWithToken(\r\n        'login',\r\n        {\r\n          action: 'login',\r\n          lgname,\r\n          lgpassword,\r\n          ...params,\r\n        },\r\n        { tokenName: 'lgtoken', ...postOptions }\r\n      )\r\n      if (res?.data?.login) {\r\n        data = res.data\r\n      } else {\r\n        throw res\r\n      }\r\n    } catch (e: any) {\r\n      if (e instanceof WikiSaikouError) {\r\n        throw e\r\n      } else if (e?.ok === false) {\r\n        return this.login(lgname, lgpassword, params, {\r\n          ...postOptions,\r\n          noCache: true,\r\n          retry: postOptions.retry - 1,\r\n        })\r\n      } else {\r\n        throw new WikiSaikouError(\r\n          WikiSaikouErrorCode.HTTP_ERROR,\r\n          \"The server returns an error, but it doesn't seem to be caused by MediaWiki\",\r\n          e\r\n        )\r\n      }\r\n    }\r\n\r\n    if (data?.login?.result !== 'Success') {\r\n      throw new WikiSaikouError(\r\n        WikiSaikouErrorCode.LOGIN_FAILED,\r\n        data?.login?.reason?.text ||\r\n          data?.login?.result ||\r\n          'Login failed with unknown reason',\r\n        data\r\n      )\r\n    }\r\n    return data.login\r\n  }\r\n  async getUserInfo() {\r\n    const { data } = await this.get<{\r\n      query: {\r\n        userinfo: {\r\n          id: number\r\n          name: string\r\n          groups: string[]\r\n          rights: string[]\r\n          blockid?: number\r\n          blockedby?: string\r\n          blockedbyid?: number\r\n          blockreason?: string\r\n          blockexpiry?: string\r\n          blockedtimestamp?: string\r\n        }\r\n      }\r\n    }>({\r\n      action: 'query',\r\n      meta: 'userinfo',\r\n      uiprop: ['groups', 'rights', 'blockinfo'],\r\n    })\r\n    return data?.query?.userinfo\r\n  }\r\n\r\n  /** Token Handler */\r\n  async getTokens(type: MwTokenName[] = ['csrf']) {\r\n    this.defaultOptions.credentials = 'include'\r\n    const { data } = await this.get({\r\n      action: 'query',\r\n      meta: 'tokens',\r\n      type,\r\n    })\r\n    this.tokens = { ...this.tokens, ...data.query.tokens }\r\n    return this.tokens\r\n  }\r\n  async token(type: MwTokenName = 'csrf', noCache = false) {\r\n    if (!this.tokens[`${type}token`] || noCache) {\r\n      delete this.tokens[`${type}token`]\r\n      await this.getTokens([type])\r\n    }\r\n    return this.tokens[`${type}token`]\r\n  }\r\n\r\n  async postWithToken<T = any>(\r\n    tokenType: MwTokenName,\r\n    body: MwApiParams,\r\n    options?: { tokenName?: string; retry?: number; noCache?: boolean }\r\n  ): Promise<FexiosFinalContext<T>> {\r\n    const { tokenName = 'token', retry = 3, noCache = false } = options || {}\r\n\r\n    if (retry < 1) {\r\n      throw new WikiSaikouError(\r\n        WikiSaikouErrorCode.TOKEN_RETRY_LIMIT_EXCEEDED,\r\n        'The limit of the number of times to automatically re-acquire the token has been exceeded'\r\n      )\r\n    }\r\n\r\n    const token = await this.token(tokenType, noCache)\r\n\r\n    const doRetry = () =>\r\n      this.postWithToken(tokenType, body, {\r\n        tokenName,\r\n        retry: retry - 1,\r\n        noCache: true,\r\n      })\r\n\r\n    return this.post<T>({\r\n      [tokenName]: token,\r\n      ...body,\r\n    })\r\n      .then((ctx) => {\r\n        const data = ctx.data\r\n        if (MediaWikiApi.isBadTokenError(data)) {\r\n          return doRetry()\r\n        }\r\n        return ctx\r\n      })\r\n      .catch((err) => {\r\n        const data = err.data\r\n        if (MediaWikiApi.isBadTokenError(data) || err?.ok === false) {\r\n          return doRetry()\r\n        } else if (typeof data === 'object' && data !== null) {\r\n          return Promise.reject(data)\r\n        } else {\r\n          throw new WikiSaikouError(\r\n            WikiSaikouErrorCode.HTTP_ERROR,\r\n            'The server returns an error, but it doesn’t seem to be caused by MediaWiki',\r\n            err\r\n          )\r\n        }\r\n      })\r\n  }\r\n  postWithEditToken<T = any>(body: MwApiParams) {\r\n    return this.postWithToken<T>('csrf', body)\r\n  }\r\n\r\n  static isBadTokenError(data?: any) {\r\n    return (\r\n      data?.error?.code === 'badtoken' ||\r\n      data?.errors?.some((i: any) => i.code === 'badtoken') ||\r\n      ['NeedToken', 'WrongToken'].includes(data?.login?.result)\r\n    )\r\n  }\r\n\r\n  async getMessages(ammessages: string[], amlang = 'zh', options: MwApiParams) {\r\n    const { data } = await this.get({\r\n      action: 'query',\r\n      meta: 'allmessages',\r\n      ammessages,\r\n      amlang,\r\n      ...options,\r\n    })\r\n    const result: Record<string, string> = {}\r\n    data.query.allmessages.forEach(function (obj: {\r\n      missing?: boolean\r\n      name: string\r\n      content: string\r\n    }) {\r\n      if (!obj.missing) {\r\n        result[obj.name] = obj.content\r\n      }\r\n    })\r\n    return result\r\n  }\r\n\r\n  async parseWikitext(\r\n    wikitext: string,\r\n    title?: string,\r\n    extraBody?: MwApiParams,\r\n    options?: FexiosRequestOptions\r\n  ): Promise<string> {\r\n    const { data } = await this.post(\r\n      {\r\n        action: 'parse',\r\n        title,\r\n        text: wikitext,\r\n        ...extraBody,\r\n      },\r\n      options\r\n    )\r\n    return data.parse.text\r\n  }\r\n}\r\n\r\nexport class MediaWikiForeignApi extends MediaWikiApi {\r\n  constructor(baseURL?: string, options?: Partial<FexiosConfigs>) {\r\n    super(baseURL, {\r\n      credentials: 'include',\r\n      ...options,\r\n    })\r\n    this.defaultParams.origin = location.origin\r\n  }\r\n}\r\n\r\n// Aliases\r\nexport default MediaWikiApi\r\nexport { MediaWikiApi as MwApi, MediaWikiForeignApi as ForeignApi }\r\n\r\n// Errors\r\nexport enum WikiSaikouErrorCode {\r\n  HTTP_ERROR = 'HTTP_ERROR',\r\n  LOGIN_FAILED = 'LOGIN_FAILED',\r\n  LOGIN_RETRY_LIMIT_EXCEEDED = 'LOGIN_RETRY_LIMIT_EXCEEDED',\r\n  TOKEN_RETRY_LIMIT_EXCEEDED = 'TOKEN_RETRY_LIMIT_EXCEEDED',\r\n}\r\nexport class WikiSaikouError extends Error {\r\n  readonly name = 'WikiSaikouError'\r\n  constructor(\r\n    readonly code: WikiSaikouErrorCode,\r\n    readonly message: string = '',\r\n    readonly cause?: FexiosFinalContext\r\n  ) {\r\n    super()\r\n  }\r\n}\r\n\r\n// Types\r\nexport type MwApiParams = Record<\r\n  string,\r\n  string | number | string[] | undefined | boolean | File\r\n>\r\nexport type MwTokenName =\r\n  | 'createaccount'\r\n  | 'csrf'\r\n  | 'login'\r\n  | 'patrol'\r\n  | 'rollback'\r\n  | 'userrights'\r\n  | 'watch'\r\n"],"names":["makeMap","str","map","key","val","extend","hasOwnProperty","hasOwn","isArray","isMap","toTypeString","isFunction","isString","isSymbol","isObject","objectToString","value","toRawType","isIntegerKey","hasChanged","oldValue","activeSub","batchDepth","batchedSub","batch","sub","startBatch","endBatch","error","e","next","err","prepareDeps","link","cleanupDeps","fromComputed","head","tail","prev","removeSub","removeDep","isDirty","refreshComputed","computed","globalVersion","dep","prevSub","prevShouldTrack","shouldTrack","nextSub","l","targetMap","prevDep","nextDep","trackStack","pauseTracking","resetTracking","last","Link","Dep","debugInfo","addSub","currentTail","ITERATE_KEY","MAP_KEY_ITERATE_KEY","ARRAY_ITERATE_KEY","track","target","type","depsMap","trigger","newValue","oldTarget","run","targetIsArray","isArrayIndex","newLength","key2","reactiveReadArray","array","raw","toRaw","isShallow","toReactive","shallowReadArray","arr","arrayInstrumentations","iterator","args","x","fn","thisArg","apply","v","searchProxy","separator","noTracking","reduce","comparer","self","method","wrapValue","iter","result","arrayProto","wrappedRetFn","needsWrap","methodFn","result2","wrappedFn","item","index","acc","res","isProxy","isNonTrackableKeys","builtInSymbols","obj","BaseReactiveHandler","_isReadonly","_isShallow","receiver","isReadonly2","isShallow2","shallowReadonlyMap","readonlyMap","shallowReactiveMap","reactiveMap","isRef","readonly","reactive","MutableReactiveHandler","isOldValueReadonly","isReadonly","hadKey","ReadonlyReactiveHandler","mutableHandlers","readonlyHandlers","toShallow","getProto","get","rawTarget","rawKey","has2","wrap","toReadonly","has","size","add","set","get2","deleteEntry","clear","hadItems","createForEach","callback","observed","createIterableMethod","targetIsMap","isPair","isKeyOnly","innerIterator","done","createReadonlyMethod","createInstrumentations","mutableInstrumentations2","shallowInstrumentations2","readonlyInstrumentations2","shallowReadonlyInstrumentations2","mutableInstrumentations","readonlyInstrumentations","shallowInstrumentations","shallowReadonlyInstrumentations","createInstrumentationGetter","shallow","instrumentations","mutableCollectionHandlers","readonlyCollectionHandlers","targetTypeMap","rawType","getTargetType","createReactiveObject","baseHandlers","collectionHandlers","proxyMap","existingProxy","targetType","proxy","r","ref","createRef","rawValue","RefImpl","useDirectValue","ComputedRefImpl","setter","isSSR","getterOrOptions","debugOptions","getter","u","s","t","b","y","m","w","o","h","i","c","n","f","d","p","g","O","_","a","T","MediaWikiApi","baseURL","options","wgServer","wgScriptPath","_b","_a","instance","ctx","name","cookieHeaders","rawCookies","Fexios","body","data","searchParams","url","origin","params","query","lgname","lgpassword","postOptions","WikiSaikouError","_d","_c","_e","noCache","tokenType","tokenName","retry","token","doRetry","ammessages","amlang","wikitext","title","extraBody","MediaWikiForeignApi","WikiSaikouErrorCode","code","message","cause"],"mappings":"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","x_google_ignoreList":[0,1,2]}